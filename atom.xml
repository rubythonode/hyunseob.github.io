<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DailyEngineering</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyunseob.github.io/"/>
  <updated>2017-01-17T15:37:08.000Z</updated>
  <id>https://hyunseob.github.io/</id>
  
  <author>
    <name>HyunSeob</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript: 제네릭(Generic)</title>
    <link href="https://hyunseob.github.io/2017/01/14/typescript-generic/"/>
    <id>https://hyunseob.github.io/2017/01/14/typescript-generic/</id>
    <published>2017-01-14T14:51:23.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/11/18/typescript-function/">TypeScript: 함수(Function)</a></p>
<p>제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다.</p>
<p>제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. Java나 C++ 등의 정적 타입 언어에서는 함수 및 클래스를 선언하는 시점에서 매개변수 혹은 리턴 타입을 정의해야하기 때문에 기본적으로는 특정 타입을 위해 만들어진 클래스나 함수를 다른 타입을 위해 재사용할 수가 없다. 때문에 제네릭을 통해 함수와 클래스의 범용적인 사용을 가능케 한다.</p>
<p>JavaScript는 원래 타입 선언이 필요하지 않고, 그렇기에 특정 타입을 위해 만들어진 클래스나 함수도 타입 에러를 런타임에서 일으킬 뿐이다. 코드를 실행시키기 전까지는 함수와 클래스가 모든 타입에 대응한다. 그렇기 때문에 JavaScript에서는 제네릭이란 말을 들을 일이 없다.</p>
<p>정적 타입 언어에서도 이렇게 특정 타입을 위해 만들어진 함수 혹은 클래스를 보다 범용적으로 재사용하기 위한 요구가 있기 때문에 제네릭이라는 프로그래밍 기법이 생긴 게 아닐까한다. TypeScript도 마찬가지로 정적 타입 언어이기 때문에, 기본적으로 타입을 정의한 함수 혹은 클래스는 모두 다른 타입에 재사용할 수 없다. 제네릭을 사용하지 않는다면 말이다.</p>
<h2 id="제네릭을-사용하는-이유"><a href="#제네릭을-사용하는-이유" class="headerlink" title="제네릭을 사용하는 이유"></a>제네릭을 사용하는 이유</h2><p>제네릭을 유용하게 사용할 수 있는 경우로는 자료구조가 있다. 다음과 같이 스택 자료구조를 TypeScript로 구현한다고 가정하자.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Stack &#123;</div><div class="line">  <span class="keyword">private</span> data: <span class="built_in">any</span>[] = [];</div><div class="line"></div><div class="line">  contructor() &#123;&#125;</div><div class="line"></div><div class="line">  push(item: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="keyword">this</span>.data.push(item);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pop(): <span class="built_in">any</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여러가지 방법으로 구현할 수 있겠지만, 스택 같은 자료구조는 대개 범용적인 타입을 수용할 수 있도록 만들어진다. 따라서 TypeScript에서는 위와 같이 <code>any</code>를 이용하여 구현할 수 있는 것이 가장 쉬운 방법이다.</p>
<p>하지만 <code>any</code>를 이용하여 구현하면 저장하고 있는 자료의 타입이 모두 같지 않다는 문제점이 생긴다. 따라서 위의 스택에서 자료를 추출하는 경우 런타임에서 항상 타입 검사를 해줘야 한다는 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</div><div class="line">stack.push(<span class="number">1</span>);</div><div class="line">stack.push(<span class="string">'a'</span>);</div><div class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// 'a'</span></div><div class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// Throw TypeError</span></div></pre></td></tr></table></figure>
<p>그렇다고 자료형을 보장하기 위해 항상 <code>number</code> 타입의 변수만 받을 수 있도록 하면, 범용성이 떨어지게 된다.</p>
<p>물론 상속으로도 이를 처리할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> NumberStack extends Stack &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  push(item: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="keyword">super</span>.push(item);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pop(): <span class="built_in">number</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>하지만 상속을 사용하는 경우에는 자료형을 하나 추가할 때마다 구태여 클래스를 추가하고 중복되는 코드를 양산해야하기 때문에 번거롭기는 마찬가지다.</p>
<p>이런 경우에 유용하게 사용할 수 있는 것이 제네릭이다.</p>
<h2 id="제네릭의-문법"><a href="#제네릭의-문법" class="headerlink" title="제네릭의 문법"></a>제네릭의 문법</h2><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>스택 자료구조를 제네릭으로 다시 구현하면 다음과 같은 형태를 띌 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</div><div class="line">  <span class="keyword">private</span> data: T[] = [];</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</div><div class="line"></div><div class="line">  push(item: T): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="keyword">this</span>.data.push(item);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pop(): T &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>클래스 식별자 선언부에 <code>&lt;T&gt;</code>라는 못보던 문법이 추가된 것을 확인할 수 있다. 제네릭을 사용하겠다는 의미로 꺽쇠(Angle brackets)를 넣고 그 안에 타입으로 사용되는 식별자를 집어넣는다.</p>
<p><code>T</code>는 Type의 약자로 다른 언어에서도 제네릭을 선언할 때 관용적으로 많이 사용된다. 이 부분에는 식별자로 사용할 수 있는 것이라면 무엇이든 들어갈 수 있다. 이를테면 <code>$</code>나 <code>_</code>도 가능하다는 의미다. 하지만 대개의 경우 <code>T</code>를 사용한다. 여기에서 <code>T</code>를 타입 변수(Type variables)라고 한다.</p>
<p>이렇게해서 클래스에서 제네릭을 사용하겠다고 선언한 경우 <code>T</code>는 해당 클래스에서 사용할 수 있는 특정한 타입이 된다.</p>
<p>사용법은 아래와 같다. 그저 생성자를 호출하여 객체를 만들 때 <code>T</code>로 사용될 타입을 지정해주기만 하면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> numberStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">number</span>&gt;();</div><div class="line"><span class="keyword">const</span> stringStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;();</div><div class="line">numberStack.push(<span class="number">1</span>);</div><div class="line">stringStack.push(<span class="string">'a'</span>);</div></pre></td></tr></table></figure>
<p>이제 각 스택은 항상 생성할 때 선언한 타입만을 저장하고 리턴한다. 이렇게 하면 컴파일러가 리턴하는 타입을 알 수 있게 되므로 에디터에서 자동 완성을 사용할 수 있게 되므로 생산성 향상에도 기여한다는 장점이 있다.</p>
<p>다만 타입은 컴파일 단계에서 검사하는 것이므로 런타임에서는 막을 수 없다. 이를테면,</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line">numberStack.push(<span class="string">''</span> as <span class="built_in">any</span>);</div></pre></td></tr></table></figure>
<p>이런<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 코드는 컴파일 단계의 타입 체크를 우회하므로 막을 수 없다.</p>
<h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>배열을 입력으로 받아 그 배열의 첫번째 요소를 출력하는(<code>lodash.head()</code> 같은) 함수를 구현해야 한다고 가정하자. 제네릭을 사용하지 않는 경우 이렇게 짜게 될 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위의 코드는 마찬가지로 어떤 타입의 배열이라도 받을 수 있기 때문에 리턴하게 되는 타입이 무엇인지 알 수 없다. 제네릭을 이용하면 다음과 같이 간단하게 구현할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>): <span class="title">T</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>추가된 것은 클래스와 동일하게 함수 식별자 옆에 들어가는 <code>&lt;T&gt;</code>이다. 마찬가지로 이 함수 내에서 <code>T</code>는 특정한 타입으로 취급된다.</p>
<p>마찬가지로 사용할 때는 함수를 호출할 때 제네릭 문법으로 타입을 정해주기만 하면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line">first&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h2 id="두-개-이상의-타입-변수"><a href="#두-개-이상의-타입-변수" class="headerlink" title="두 개 이상의 타입 변수"></a>두 개 이상의 타입 변수</h2><p>제네릭 함수나 클래스에서는 두 개 이상의 타입 변수도 사용할 수 있다. 다음과 같이 두 가지 변수를 받아 쌍으로 만들어 반환하는 함수를 구현해야 한다고 가정하자.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): [ <span class="title">any</span>, <span class="title">any</span> ] </span>&#123;</div><div class="line">  <span class="keyword">return</span> [ a, b ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>입력되는 두 가지의 변수의 타입이 다르다고 가정할 경우 두 가지의 타입 변수가 필요하게 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a: T, b: U</span>): [ <span class="title">T</span>, <span class="title">U</span> ] </span>&#123;</div><div class="line">  <span class="keyword">return</span> [ a, b ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>제네릭을 사용하면 위와 같은 형태로 구현할 수 있다. 꺽쇠 안에 <code>T</code>와 <code>U</code> 두 가지의 타입 변수가 보일 것이다. 아까 관용적으로 <code>T</code>를 사용한다고 말했는데, 그 뒤로는 알파벳 순서대로 사용하면 된다. 반복문에서 관용적으로 인덱스 변수로 <code>i</code>, <code>j</code>를 사용하는 것과 비슷하다.</p>
<p>함수 사용법은 아래와 같다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line">toPair&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">'1'</span>, <span class="number">1</span>); <span class="comment">// [ '1', 1 ]</span></div><div class="line">toPair&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [ 1, 1 ]</span></div></pre></td></tr></table></figure>
<h2 id="상속된-타입-변수"><a href="#상속된-타입-변수" class="headerlink" title="상속된 타입 변수"></a>상속된 타입 변수</h2><p>타입 변수는 기존에 사용하고 있는 타입을 상속할 수도 있다. 이 점을 이용하면 입력 받을 변수의 타입을 제한할 수 있다. 또한 에디터가 해당 타입의 메소드나 프로퍼티를 예측할 수 있으므로 자동 완성이 된다.</p>
<p>이것과 여러 개의 타입 변수를 사용해 응용하면 아래와 같은 코드를 짤 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirst</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Stack</span>&lt;<span class="title">U</span>&gt;, <span class="title">U</span>&gt;(<span class="params">container: T</span>): <span class="title">U</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> item = container.pop();</div><div class="line">  container.push(item);</div><div class="line">  <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getFirst</code>는 입력받은 스택의 첫번째 요소를 반환하는 함수다. 사용시에는 아래처럼 사용하면 된다. 만약 첫 번째 타입으로 스택, 혹은 스택을 상속한 타입이 아닌 다른 타입을 사용하면 에러가 발생한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line">getFirst&lt;Stack&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>)(numberStack);</div><div class="line">getFirst&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>); <span class="comment">// Type 'number' does not satisfy the constraint 'Stack&lt;number&gt;'.</span></div></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">하지만 실제로 TypeScript를 실서비스에 적용하다보면 이러한 코드를 어쩔 수 없이 짜게되는 경우가 좀 있다. 물론 지양해야 한다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/11/18/typescript-function/&quot;&gt;TypeScript: 함수(Function)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제네릭은 Java 등의 정적 
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox 활용사례 모음: Solved by Flexbox</title>
    <link href="https://hyunseob.github.io/2017/01/09/solved-by-flexbox/"/>
    <id>https://hyunseob.github.io/2017/01/09/solved-by-flexbox/</id>
    <published>2017-01-09T14:41:24.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="https://hyunseob.github.io/solved-by-flexbox-kr/images/vertical-centering.jpg"/><p><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">Flexbox</a>는 웹페이지에서 다양한 레이아웃을 만들기 위해서 쓸 수 있는 최신 CSS 기능이다. 사실 지금까지 CSS를 이용해서 레이아웃을 만드는 것이 그리 간단한 일은 아니었다. 수직 중앙 정렬은 잘 알려진 문제 중 하나다. 물론 지금까지 해결방법이 없었던 것은 아니지만 대개는 CSS Hack을 사용해야 하므로 코드가 직관적이지 않았으며, 쓸데없는 속성을 사용해야만 했다. 게다가 어떤 때에는 JavaScript를 사용해야 이런 문제를 해결할 수 있었다. 이런 수 많은 레이아웃 문제를 해결하기 위해 나온 스펙이 Flexbox다. Flexbox는 직관적인 코드를 제공하면서도 원하는 기능을 쉽게 구현할 수 있도록 만들어준다.</p>
<h2 id="좋은-거-나도-아는데-IE는-어쩔껴"><a href="#좋은-거-나도-아는데-IE는-어쩔껴" class="headerlink" title="좋은 거 나도 아는데, IE는 어쩔껴?"></a>좋은 거 나도 아는데, IE는 어쩔껴?</h2><p><a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">Can I use</a>를 보면 모던 브라우저는 완벽하게 지원하고 있지만 당연하게도 IE쪽에 문제가 있다. IE9 이하의 버전은 지원하지도 않으며 그나마 10부터는 지원을 하고있지만 많은 버그를 안고있다는 문제가 있다. Flexbox 제대로 프로덕션에서 사용하려면 IE9 이하는 대응을 포기하고, 추가적으로 크로스 브라우징을 위한 호환 코드가 필요하다. 많은 한국 사이트들은 아직도 IE9는 커녕, IE8 혹은 그 이하까지 대응해야하기 때문에 지금 당장 사용하는 것은 사실상 불가할 수도 있다.</p>
<p>그럼에도 Flexbox는 근시일내에 다가올 것이다. 매년 브라우저 사용률은 변화하고 있고, 분명 1년 전에 제작된 사이트들과 현재 제작되는 사이트들이 지원을 요구하는 브라우저 목록이 달라졌다. 나조차도 당장 얼마 전 새로 제작하게 된 사이트가 IE9 이하의 구버전을 대응하지 않기로 하면서, 원한다면 얼마든지 Flexbox를 사용할 수 있었다. 아쉽게도, 내가 Flexbox를 잘 몰랐고, 때문에 Flexbox를 사용해 개발하면 브라우저 호환성을 보장하기가 어려웠다(두려웠다). 결국 기존의 방식을 고수하여 개발을 했다. 웹 개발자로서 미래를 미리 준비하지 않는다면 나처럼 안타까운 상황이 발생할 수 있다.</p>
<h2 id="Solved-by-Flexbox"><a href="#Solved-by-Flexbox" class="headerlink" title="Solved by Flexbox"></a>Solved by Flexbox</h2><p>Solved by Flexbox는 Flexbox의 활용사례를 알아볼 수 있는 모음집이다. 잘 알려진 어려운 레이아웃 이슈들에 대해 다루며 그것을 Flexbox로 어떻게 해결할 수 있는지를 보기 쉽게 알려준다. 내가 약 1년 전에 번역한 <a href="/2016/02/21/how-to-become-a-great-frontend-engineer/">탁월한 프론트엔드 엔지니어</a>의 저자인 <a href="https://github.com/philipwalton" target="_blank" rel="external">Philip Walton</a>의 가장 핫한 프로젝트다. 번역이 필요할 정도로 그리 어려운 내용을 다루고 있지는 않지만 개인 공부 목적으로 번역을 시작했다. 코드가 <a href="https://en.bem.info/" target="_blank" rel="external">BEM</a> 스타일의 컴포넌트 단위로 잘 만들어져있기 때문에 실제 프로젝트에 접목해서 사용하기에도 좋다. Flexbox에 관심이 있으신 분은 꼭 한 번 참고해보시고 오역이나 더 매끄러운 번역은 <a href="https://github.com/HyunSeob/solved-by-flexbox-kr" target="_blank" rel="external">레포지토리</a>에 PR을 날려주시면 감사하겠다.</p>
<ul>
<li><a href="https://philipwalton.github.io/solved-by-flexbox/" target="_blank" rel="external">원문</a></li>
<li><a href="https://hyunseob.github.io/solved-by-flexbox-kr/">한국어 번역</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://hyunseob.github.io/solved-by-flexbox-kr/images/vertical-centering.jpg&quot;/&gt;&lt;p&gt;&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot; 
    
    </summary>
    
      <category term="CSS" scheme="https://hyunseob.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hyunseob.github.io/tags/CSS/"/>
    
      <category term="Translate" scheme="https://hyunseob.github.io/tags/Translate/"/>
    
  </entry>
  
  <entry>
    <title>2016년 블로그 운영 회고</title>
    <link href="https://hyunseob.github.io/2016/12/10/a-look-back-on-blog-in-2016/"/>
    <id>https://hyunseob.github.io/2016/12/10/a-look-back-on-blog-in-2016/</id>
    <published>2016-12-10T07:12:00.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/a-look-back-on-blog-in-2016.jpg"/><p>올 한 해 스스로 잘했다고 생각하는 것 중에 하나는 바로 블로그 운영이다. 사실 블로그는 작년에 시작했다. 작년 8월 쯤, 그러니까 첫 커리어의 시작 즈음에, 스스로의 실력에 대한 회의감, 위기감 이런 것들이 촉매가 되어 시작하게 된 것 같다.</p>
<p>포스트 고작 3개. 그리고 나서 테마가 좀 맘에 안 들어서 “그래, 역시 웹 개발자라면 블로그 테마 정도는 스스로 만드는 거지!” 하면서 나름대로 테마를 만들어보려고 꼼지락거렸던 것 같다. 당시에는 블로그 구성이 지금과는 조금 달랐다. 정적 사이트 제너레이터로 만든 블로그라는 점은 같았지만, Ruby 기반의 Jekyll을 사용해서 구성했었고 웹 개발자로서도 많이 부족했기 때문에 금방 포기했었다.</p>
<p>그리고 2016년이 찾아왔다. 여러가지 글이 나에게 블로그를 하라고 가리키는 듯 했다. 연초에 강미경님이 쓰신 <a href="https://minieetea.com/2016/01/archives/4332" target="_blank" rel="external">이 글</a>에서도 영향을 받았고, 당시 내가 번역하려다 미루어 두었던(지금은 이미 번역된) <a href="https://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/" target="_blank" rel="external">How to become a great frontend engineer</a>라는 글에서도 마지막에 글을 쓰라는 내용으로 맺는다.</p>
<p>다들 하는 것처럼 나도 연초에 목표를 세우곤 하는데, 결국 나는 그 목표 중 하나로 1주 1포스팅을 끼워넣게 되었다. 물론, 현실성 없는 설정으로 인해 이 목표는 불과 한 달도 안되어 깨졌다. 그래도 이 목표가 나에게 글을 쓰게 된 계기를 만들어 준 것은 사실이다. 더불어 올해 2월에 이상한모임에 필진으로 등록되면서 동기부여가 더욱 강해졌다.</p>
<h2 id="블로그를-다시-시작하면서-기대한-것"><a href="#블로그를-다시-시작하면서-기대한-것" class="headerlink" title="블로그를 다시 시작하면서 기대한 것"></a>블로그를 다시 시작하면서 기대한 것</h2><p>시작할 당시에는, 블로그로 인해 내가 아는 것의 스펙트럼이 넓어질 거라고 생각했다. 나는 기억력이 안 좋은 편인데, 일단 글로 기록을 했으니 당연히 기억도 더 오래 남을 것이라고 기대했다. 그리고 결국은 블로그가 나중에 개발자로서의 자산, 그러니까 포트폴리오로 남을 것이라는 기대를 했다.</p>
<h2 id="실제로는-어땠는가"><a href="#실제로는-어땠는가" class="headerlink" title="실제로는 어땠는가"></a>실제로는 어땠는가</h2><p>1년 동안 글을 써보니 블로그를 통해서 새롭게 알게 되는 것이 생기는 경우는 많이 없었던 것 같다. 오히려 내가 평범하게 일을 하거나 모임에 나가서 알게 되는 것들을 블로그에 적게 되는 경우가 훨씬 많은 것 같다. 블로그에 글을 쓰기 위해서 특정 기술에 대해서 공부를 한 적도 있긴하지만, 이 때는 내가 알고 있는 걸 표현할 때보다 동기부여도 약해졌고, 글을 쓰는데에도 더 오래 걸렸다.</p>
<p>글로 썼다고 기억이 더 잘 나는 것도, 적어도 나에게는 아닌 것 같다. “내가 대충 그런 주제의 글을 썼다”라는 것은 기억이 나는데, 내용은 자세히 기억에 남지 않았다. 대신에 내가 쓴 글은, 기억이 나지 않아도 내가 가장 빠르게 참고할 수 있는 자료가 되어서 삽질을 조금 줄일 수 있게 되었다.</p>
<p>그리고 쓰는 주제에 대해서 더 확실히 알게 된다. 엄청 많은 사람이 내 글을 읽는 건 아니지만, 이상한모임에도 퍼블리싱 되는 글이고, 구독자 수도 나름(…)대로 꽤 있어서 글 내용에 혹시라도 오류가 있지는 않을 지 꼼꼼하게 확인하게 된다. 그 과정에서 내가 애매하게만 알고 있었던 내용을 명확하게 알게 되는 경우가 많았다. 그럼에도 불구하고 글 내용에 종종 오류가 있었다. 잘못된 정보를 전달받은 분들께 죄송하다는 말씀을 전하고 싶다.</p>
<p>더불어 블로그를 운영하면서 “내 글이 읽힌다” 라는 게 이렇게 기분 좋은 일인지 처음 알게 되었다. 다른 분들이 보고 댓글을 남기시거나 좋아요를 눌러 주시는 일련의 반응들이, 나에게는 글을 쓰게 되는 또 하나의 동기가 되었다. 습관적으로 GA에 들어가서 내 글이 어디에 링크가 되어있는 지 찾아보는 게 취미가 되었다.</p>
<p>포트폴리오는 되는 게 맞는 것 같다. 최소한 취업 혹은 이직에 도움이 되는 것은 맞다. 얼마 전 <a href="/2016/10/15/my-first-changing-company/">이직</a>하면서 이력서 내용에 블로그 링크를 추가해뒀는데, 면접을 가게 되면 감사하게도 대부분 블로그를 좋은 방향으로 언급해주셨다.</p>
<p>마지막으로 나의 과거를 돌아볼 수 있게 된다는 점이 있다. 나는 연말이 되면 항상 1년 회고를 해보는데, 사실 1년 전 자신이 어떤 수준인지 명확하게 떠올리기 어려웠다. 글로서 기록을 블로그에 남겨두니 1년 전에 내가 어떤 수준이었는지 파악하기 쉬워졌다. 덕분에 내가 얼마나 발전했는지도 알기가 쉽다. 이건 다시 앞으로의 1년을 달릴 수 있게 만드는 에너지가 된다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이 글을 쓰는 시점에서 세어보니, 올 해 나는 27개의 포스트를 작성했다. 그러니까 약 2주에 1개의 포스트를 작성한 것이다. 목표는 달성하지 못했지만, 이 정도면 꽤 괜찮지 않았나, 하고 스스로 칭찬해본다.</p>
<p>2016년 한 해 동안 블로그에 방문해주신 모든 분께 감사드린다.</p>
<h2 id="2016년-통계"><a href="#2016년-통계" class="headerlink" title="2016년 통계"></a>2016년 통계</h2><p>의미 없는 통계치지만 통계를 내는 걸 좋아해서 기록해본다. Google Analytics의 통계이므로 정확하지 않다. 광고 차단 플러그인 등을 사용했다면 잡히지 않을 수도 있다.</p>
<ul>
<li>방문자 수: 43,246명<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li>Feedly 구독자 수: 62명</li>
<li>가장 많이 읽힌 글: <a href="/2016/02/21/how-to-become-a-great-frontend-engineer/">탁월한 프론트엔드 엔지니어가 되는 법</a>(11,399 hit)</li>
<li>가장 많이 읽힌 비번역 글: <a href="/2016/04/03/webpack-practical-guide/">webpack 실전 가이드</a>(7,077 hit)</li>
<li>Google 유입 방문자 수: 15,247명</li>
<li>Google 유입이 많이 된 글: webpack 실전 가이드(4,219명), <a href="/2016/02/08/copy-object-in-javascript/">JavaScript 객체 복사하기</a>(3,981명)</li>
<li>Facebook 유입 방문자 수: 15,134명<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
<li>Facebook 유입이 많이 된 글: 탁월한 프론트엔드 엔지니어가 되는 법(4,686명), <a href="/2016/09/17/lambda-anonymous-function-closure/">람다, 익명 함수, 클로저</a>(4,231명)</li>
</ul>
<p><img src="/images/2016-ga-stat.png" alt="Google Anaytics 검색 유입 통계 2016"><br>위의 그래프는 GA에서 구글 검색으로만 유입되는 세션 수다. 수치는 많지 않지만 그래프가 예쁘게 나와서 가져와 본다. 꾸준히 하면 적어도 조금씩 트래픽이 증가한다.</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">세션 기준.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">GA에 <code>(direct) / (none)</code>으로 잡히는 사용자 중 페이스북 비율이 꽤 있을 것으로 예상되지만 예측할 수 없으므로 제외하였다.</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/a-look-back-on-blog-in-2016.jpg&quot;/&gt;&lt;p&gt;올 한 해 스스로 잘했다고 생각하는 것 중에 하나는 바로 블로그 운영이다. 사실 블로그는 작년에 시작했다. 작년 8월 쯤, 그러니까 첫 커리어의 시작 즈
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Blog" scheme="https://hyunseob.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>[책] 함수형 사고</title>
    <link href="https://hyunseob.github.io/2016/12/05/book-functional-thinking/"/>
    <id>https://hyunseob.github.io/2016/12/05/book-functional-thinking/</id>
    <published>2016-12-04T16:22:41.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>요즘 함수형 프로그래밍에 관심이 많다. 나뿐만 아니라 함수형 패러다임을 도입하는 것이 프로그래밍계의 트렌드라는 생각이다. 대표적으로 2014년에 도입된 Java 8을 꼽을 수 있겠으며 <a href="/2016/11/21/misunderstanding-about-const/">앞선 글</a>에서도 말했듯 prefer-const도 함수형 패러다임의 일종이다.</p>
<p>그렇다면 함수형 프로그래밍이란 무엇을 뜻하는 걸까? <a href="https://michaelfeathers.silvrback.com/bio" target="_blank" rel="external">마이클 페더스</a>는 함수형 프로그래밍에 대해서 이렇게 말했다.</p>
<blockquote>
<p>객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다.</p>
</blockquote>
<p>즉, 변수를 최소화하는 프로그래밍 패러다임이라는 것이다.</p>
<p><img src="/images/functional-thinking.jpeg" alt="함수형 사고"></p>
<p>이 책에서는 객체지향 프로그래밍을 함수형으로 어떻게 전환하는지 예제 중심으로 다룬다. 이어서 함수형 프로그래밍의 핵심적인 요소들(람다, 순수함수, 클로저, 게으른 평가 등)에 대해서도 예제와 함께 다뤄 이해하기 수월하다. 하지만 이 책은 함수형 프로그래밍 언어를 중점으로 다루지는 않는다. 그냥 함수형 구현을 하는 것에 초점이 맞춰져 있다. 사용하는 언어도 Scala나 Clojure 같은 언어도 등장하지만 일단은 Java를 중점으로 사용하고 있다. 후반부에는 특정 언어에 한정되는 트릭도 등장하면서 약간 아쉽기도 했지만 큰 문제는 아니었다.</p>
<p>코드는 대부분 Java 위주에, Scala, Clojure<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 같은 언어도 사용하기 때문에 기반이 거의 JavaScript인 나에게는 이해하기 어려운 코드도 좀 있었다. 특히나 Clojure로 짠 코드는 문법이 익숙하지 않았던 탓인지 내게는 거의 난해한 프로그래밍 언어 수준. 그러나 대부분의 경우 설명하고자 하는 것에 대해 이해하기 어려울 정도는 아니다. 그래도 Java를 다루어 본 적이 없는 개발자라면 기본적인 문법 정도는 공부를 하고 읽어야 할 것이다.</p>
<p>당연하지만 함수형 언어를 배우기 위해서 이 책을 보는 건 큰 의미가 없다. 그보다는 지금 사용하는 언어 그대로 사용하면서 거기에 함수형 패러다임을 섞어 조금씩 개선해 나가고 싶은 사람이 읽으면 좋을 것이다. 실제로 나도 계속해서 JavaScript라는 하나의 언어를 사용하고 있지만 이 책을 보기 전과 그 뒤의 코드가 많이 달라졌고, 생각하는 방식도 많이 달라졌다. 물론 이는 ES2015를 위시한 JavaScript라는 언어가 함수형 패러다임을 써먹기에도 꽤 잘 되어있기 때문이다.</p>
<p>객체지향과 함수형은 상호배타적이지 않다.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 책 마지막 부분에서도 이를 언급하면서 폴리패러다임(Poly-paradigm)에 대해 소개한다. 함수형과 객체지향적 패러다임을 모두 이해함으로써 필요할 때 적절히 활용할 수 있다는 점이 중요하다고 생각한다.</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Clojure의 경우 클로저라고 번역되어 클로저(Closure)랑 헷갈려서 난해한 문장도 좀 있었다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">함수형 프로그래밍 규칙을 엄격하게 적용하면 모든 객체의 Setter를 없애고 내부 상태를 변경하는 것을 금지하기도 한다. 이 점은 객체지향과는 약간 상반된다고 할 수 있겠다.</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;요즘 함수형 프로그래밍에 관심이 많다. 나뿐만 아니라 함수형 패러다임을 도입하는 것이 프로그래밍계의 트렌드라는 생각이다. 대표적으로 2014년에 도입된 Java 8을 꼽을 수 있겠으며 &lt;a href=&quot;/2016/11/21/misunderstand
    
    </summary>
    
      <category term="Book" scheme="https://hyunseob.github.io/categories/Book/"/>
    
    
      <category term="Functional" scheme="https://hyunseob.github.io/tags/Functional/"/>
    
  </entry>
  
  <entry>
    <title>const에 대한 오해</title>
    <link href="https://hyunseob.github.io/2016/11/21/misunderstanding-about-const/"/>
    <id>https://hyunseob.github.io/2016/11/21/misunderstanding-about-const/</id>
    <published>2016-11-20T16:33:11.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/misunderstanding-about-const.png"/><h2 id="const-is-not-immutable"><a href="#const-is-not-immutable" class="headerlink" title="const is not immutable?"></a><code>const</code> is not immutable?</h2><p>얼마 전에 어떤 페이스북 그룹에서 공유된 글 중에 <a href="https://mathiasbynens.be/notes/es6-const" target="_blank" rel="external">이런 글</a>이 있었다. 본문에는 이런 문장이 있다.</p>
<blockquote>
<p>ES6 <code>const</code> does not indicate that a value is ‘constant’ or immutable. A <code>const</code> value can definitely change.</p>
</blockquote>
<p>여기서는 <code>const</code>에 할당된 값이 바뀔 수 있다고 한다. 믿겨지는가? 값이 바뀐다면 어떻게 상수(Constant)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>라고 할 수 있을까?</p>
<p>오해하지말자. <code>const</code> 변수에 할당된 값은 <strong>절대로</strong> 바뀌지 않는다. 여기서는 재할당만 막는 걸 보장한다고 되어있지만, 재할당을 막는 게 곧 값을 못 바꾼다는 얘기다. 이건 그냥 말장난, 혹은 동어 반복이다.</p>
<p>그러면서 드는 예가 Object다. 다들 아시겠지만 Object가 변수에 할당될 때는 Object 자체가 할당되는 게 아니라 <strong><a href="http://stackoverflow.com/questions/6605640/javascript-by-reference-vs-by-valuet" target="_blank" rel="external">Object의 주소가 할당</a></strong>된다. 이는 JavaScript 개발자라면 당연히 기본적으로 알아야할 사항이다. (그러나 안타깝게도 나는 <a href="2016/02/08/copy-object-in-javascript/">올해 2월까지는 JavaScript 개발자가 아니었던 것 같다.</a>) <code>{} === {}</code>가 거짓을 반환하는 이유에 대해 다들 알고 있지 않은가? <code>const</code> 변수에 Object를 할당하면 당연히 Object를 가리키는 주소 <strong>값</strong>이 할당된다. 그리고 이 주소 값은 불변이고, 상수다. 그러나 그 Object에 Key-Value 쌍을 추가하거나 변경하는 행위는 가능하다. 예외인게 아니고 당연하다. 이 값은 <code>const</code>에 바인딩 되는 값이 아니니까.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="external">MDN</a>에서도 비슷한 방식으로 설명하고 있다. 이런 식으로 밖에 설명할 수 밖에 없는 이유가 대체 뭔지 정말 안타깝다. <del>그냥 주소 값을 때려박는다고 왜 말을 못해!</del> Object 내의 값을 뭘로 바꾸든 간에 그건 변수에 할당된 값을 바꾸는 것이 아니다. 그래.. C 배울 때도 포인터가 제일 어렵긴 했었지..</p>
<h2 id="요즘-const-사용법"><a href="#요즘-const-사용법" class="headerlink" title="요즘 const 사용법"></a>요즘 <code>const</code> 사용법</h2><p>그 외 글의 논조 자체에는 동의한다. 원문에서는 변수 사용시에 다음과 같이 하라고 되어있다.</p>
<ol>
<li>기본적으로는 <code>const</code>를 사용한다.</li>
<li>재할당이 필요한 경우에만 <code>let</code>을 사용한다.</li>
<li><code>var</code>는 ES2015에서는 쓰지 않는다.</li>
</ol>
<p>이상하거나 어색하게 느끼실 분도 계실 것이다. <code>const</code>는 상수에만 쓰는 거 아닌가 하고 말이다. 맞다. <code>const</code>는 상수에만 쓰는 것이다. 그러므로 이 말은 이렇게 표현할 수 있다. “기본적으로 상수를 사용하라”</p>
<p>왜 이렇게 해야할까? 원문에서는 <code>const</code>가 항상 같은 객체를 가리키므로 코드가 읽기 편해진다고 한다. 물론 맞는 말이다. 하지만 나는 보다 근본적으로 접근해야 한다고 본다. 요즘 프로그래밍 패러다임에서는 <a href="https://gamecodingschool.org/2015/06/25/%EC%99%9C-%EB%B3%80%EC%88%98%EA%B0%80-%EB%82%98%EC%81%9C%EA%B0%80/" target="_blank" rel="external">변수가 나쁘다</a>고 본다. <a href="http://softwareengineering.stackexchange.com/questions/278652/how-much-should-i-be-using-let-vs-const-in-es6" target="_blank" rel="external">이 질문</a>의 첫번째 답변에서는 예상치 못한 변수의 변경으로 인해 많은 버그가 발생한다고 한다. 굳이 함수형 프로그래밍이 아니더라도, 코드의 흐름을 따라가기 위해 변하는 부분을 최소화 하는 게 요즘 프로그래밍 패러다임이다. <code>const</code>를 우선시해서 쓴 코드를 읽게 된다면 <code>let</code>은 자연히 재할당하게 되는 변수겠거니, 하고 알기 쉬운 건 덤이다. 그 유명한 <a href="https://github.com/airbnb/javascript#variables--const" target="_blank" rel="external">Airbnb의 스타일 가이드</a>에서도 <code>const</code>를 우선하는 걸 권장하고 있으며, 이는 <a href="http://eslint.org/docs/rules/prefer-const" target="_blank" rel="external">ESLint의 룰</a>로도 존재한다.</p>
<p>실제로 <code>const</code>를 우선시하는 코딩을 시작해보면 놀랄만큼 <code>let</code>을 쓸일이 없다는 것을 경험하게 된다. 아니, 사실 <code>let</code>을 쓰던 때에도 <code>const</code>를 써서 해결할 방법이 많았다는 것을 알 수 있게 된다. 예를 들면, 조건에 따라 동적으로 변수에 값을 할당할 때 <code>let</code>을 쓴다면 아래와 같이 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> foo, bar;</div><div class="line"><span class="keyword">if</span> (a === b) &#123;</div><div class="line">  foo = a;</div><div class="line">  bar = b;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  foo = b;</div><div class="line">  bar = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 경우는 언뜻 보기에 <code>const</code>를 써서 할당할 방법이 없는 것처럼 보이지만 디스트럭처링과 삼항연산자를 섞어주면 쉽게 해결이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> [foo, bar] = (a === b) ? [a, b] : [b, a];</div></pre></td></tr></table></figure>
<p>더 Geek 해보이기 위해 IIFE를 사용해보자. (-_-;)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> [foo, bar] = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (a === b) &#123;</div><div class="line">    <span class="keyword">return</span> [a, b];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> [b, a];</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>더구나 위에서 말했던 것처럼 주소값이 불변인 것이지 Object 내의 값이나 상태는 얼마든지 변할 수 있으므로 실제 레거시 코드를 <code>const</code> 우선의 코드로 수정하는 것도 어렵지 않다. 다만 객체 내부의 상태는 여전히 변경 가능하므로 모든 변수를 통제하고 있지는 못하다는 점을 상기해야겠다.</p>
<p>당연히 Object 내부 상태까지 불변값으로 고정시키는 것이 가장 바람직한 일이겠지만, 현재로서는 완벽한 방법이 없다. 원문에서는 객체의 키값까지 통제하기 위한 수단으로 <code>Object.freeze</code>를 언급하고 있지만, 이건 단기적인 해결책밖에는 안된다. 실질적으로는 페이스북이 만든 라이브러리인 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable</a>를 사용하는 게 가장 나은 수단으로 보인다. TypeScript에서는 <code>readonly</code> 프로퍼티를 이용하면 불변 객체를 만들 수 있다. (이 경우엔 런타임 불변은 아니다.) 다만, 실질적으로 객체지향 프로그래밍 패러다임에서 완벽하게 불변 객체만을 사용해서 코딩하는 것은 정말 어렵기 때문에 이런 방법도 있다 정도로만 보는 게 좋을 것 같다.</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><code>const</code>는 Constant의 약자 맞다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/misunderstanding-about-const.png&quot;/&gt;&lt;h2 id=&quot;const-is-not-immutable&quot;&gt;&lt;a href=&quot;#const-is-not-immutable&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="ES2015" scheme="https://hyunseob.github.io/categories/JavaScript/ES2015/"/>
    
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/tags/JavaScript/"/>
    
      <category term="ES2015" scheme="https://hyunseob.github.io/tags/ES2015/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 함수(Function)</title>
    <link href="https://hyunseob.github.io/2016/11/18/typescript-function/"/>
    <id>https://hyunseob.github.io/2016/11/18/typescript-function/</id>
    <published>2016-11-17T16:31:00.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/10/17/typescript-interface">TypeScript: 인터페이스(Interface)</a></p>
<h2 id="함수-타입-선언"><a href="#함수-타입-선언" class="headerlink" title="함수 타입 선언"></a>함수 타입 선언</h2><p>전에 한 번 다룬대로, TypeScript는 함수에도 타입을 선언할 수 있다. 타입 지정 대상은 함수로 전달되는 매개변수와 최종 리턴 값이 될 수 있다. 타입은 다음과 같이 선언한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">string</span>[] </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>매개변수는 식별자 뒤에 쌍따옴표 표기를 하고 타입을 선언하면 되고, 리턴 타입은 매개변수 선언 다음에 하면 된다.</p>
<p>함수를 할당할 변수에도 타입 선언이 가능하다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> myFn: <span class="built_in">Function</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;;</div></pre></td></tr></table></figure>
<p>기본적으로 TypeScript에는 <code>Function</code> 이라는 인터페이스가 내장되어있기 때문에 위와 같이 선언만 해도 함수외에 다른 값은 할당할 수 없다. 그러나 위처럼 함수 인터페이스를 선언하면 매개변수와 리턴 값에 상관없이 어떤 함수라도 할당할 수 있기 때문에 조금 더 Strict한 함수 인터페이스를 선언 하기에는 부족한 면이 있다. 따라서 TypeScript에서는 이런 변수에도 할당될 함수의 인터페이스를 선언할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> myFn: (<span class="built_in">string</span>) =&gt; <span class="built_in">string</span>[] = split;</div><div class="line">myFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;; <span class="comment">// Type '() =&gt; void' is not assignable to type '(string: any) =&gt; string[]'. Type 'void' is not assignable to type 'string[]'.</span></div></pre></td></tr></table></figure>
<p>당연하지만 기존에 선언했던 함수의 인터페이스와 실제 할당된 함수의 인터페이스가 다르다면 타입 에러가 뜬다.</p>
<h2 id="함수-오버로딩-Function-overloading"><a href="#함수-오버로딩-Function-overloading" class="headerlink" title="함수 오버로딩(Function overloading)"></a>함수 오버로딩(Function overloading)</h2><p>JavaScript에서는 기본적으로 모든 함수가 가변적으로 인자를 받을 수 있었다. 기본적으로 3개의 인자를 받아야하는 함수일지라도, 아무것도 넘기지 않고도 타입 에러 없이 함수를 호출하는 것이 가능했다. 물론 내부 로직에서 레퍼런스 에러가 뜰 수 있겠지만.</p>
<p>어쨌든 TypeScript에서는 모든 함수가 가변인자를 받지는 못한다. 기본적으로는 딱 함수를 선언할 때 명시한 만큼의 인자를 받아야만 타입 에러를 피할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// `noImplicitAny`를 `false`로 설정한다면, 꼭 타입 선언을 해야만 하는 건 아님.</span></div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">1</span>); <span class="comment">// Error</span></div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// Error</span></div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>하지만 이렇게 정해진 숫자의 인자만 받을 수 있다면 많은 프로그래밍 요구사항을 해결하기가 어려워 진다. JavaScript에서는 흔히 Optional한 동작을 하는 함수의 경우 부가적인 매개변수를 요구하기도 한다. 예를 들면, Deep copy 옵션을 줄 수도 있는, jQuery의 <code>extend</code> 메소드 같은 경우. 이 때, <a href="https://en.wikipedia.org/wiki/Function_overloading" target="_blank" rel="external">함수 오버로딩(Function overloading)</a>을 통해 전달받는 매개변수의 숫자에 따라서 다른 루틴을 타게 만들어서 이런 요구사항을 만족시킬 수가 있다.</p>
<p>C나 Java같은 정적 타입 언어의 경우, 매개변수의 갯수와 타입에 따라서 정적으로 <strong>여러 개</strong>의 함수를 구현할 수 있다. JavaScript는 이미 알고있겠지만, <strong>하나</strong>의 함수 내부에서 타입 검사를 해서 동적으로 오버로딩을 구현할 수 있다. TypeScript의 경우, 오버로딩이 불가능하지는 않지만 그 방식은 정적 타입 언어인 C나 Java보다는 동적 타입언어인 JavaScript와 유사하다. 다른 인자를 받는 <strong>여러 개</strong>의 함수를 구현하는 것이 아니라, <strong>하나</strong>의 함수에서 인자의 타입이나 갯수에 따라 여러 분기를 태우는 것이다.</p>
<p>일단 TypeScript는 함수에 정해진 타입과 정해진 수의 인자를 넘기지 않으면 에러를 발생시키므로 함수를 선언할 때 어느정도의 유연성을 확보해야 오버로딩을 구현할 수 있다. 인자 갯수의 유연성을 확보하는 것이 바로 Optional Parameter다.</p>
<h3 id="Optional-Parameter"><a href="#Optional-Parameter" class="headerlink" title="Optional Parameter"></a>Optional Parameter</h3><p>Optional Paramter는 말 그대로 선택적 매개변수. 즉, 호출할 때 끼워줘도 되고 안 끼워줘도 되는 매개변수이다. 두 경우 모두 에러없이 호출할 수 있으므로 함수 오버로딩에 필수적이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target: <span class="built_in">any</span>, deep?: <span class="built_in">boolean</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (deep) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extend(&#123; foo: <span class="string">'bar'</span> &#125;); <span class="comment">// OK</span></div><div class="line">extend(&#123; foo: <span class="string">'bar'</span> &#125;, <span class="literal">true</span>); <span class="comment">// OK</span></div><div class="line">extend(&#123; foo: <span class="string">'bar'</span> &#125;, <span class="literal">true</span>, <span class="number">1</span>); <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p><code>?</code>가 붙은 매개변수에 주목하자. Optional Parameter가 의미하는 그대로, <code>?</code>가 붙은 매개변수는 넣어도 안 넣어도 함수의 호출에는 문제가 없다. 덕분에 함수 내부에서는 해당 매개변수의 유무를 검사함으로써 다른 동작을 수행할 수 있다.</p>
<h3 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a><a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" target="_blank" rel="external">Union Type</a></h3><p>이제 인자의 갯수에 따라 다른 동작을 시킬 수 있게 되었다. 하지만 인자의 타입에 따라 다른 동작을 수행시키고 싶다면 어떻게 해야 할까? 주로 생성자에서 이런 요구가 종종 발생하곤 한다. 다음 예제를 보자.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">  age: <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">person: Person</span>) &#123; <span class="comment">// Multiple constructor implementations are not allowed. constructor Person(age: number): Person</span></div><div class="line">    <span class="keyword">this</span>.age = person.age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 처럼 생성자에 다른 타입의 매개변수를 넘기는 경우 다른 동작을 호출할 수 있도록 구현하고 싶지만 TypeScript에서는 중복된 식별자를 가진 메소드 구현을 지원하지 않으므로 에러가 발생한다.</p>
<p>이런 경우는 Union Type을 사용하면 해결할 수 있다. Union Type은 ‘Union’이 의미하는 합집합, 즉 OR에 가깝다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">  age: <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">arg: <span class="built_in">number</span> | Person</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">'number'</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.age = arg;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">      <span class="keyword">this</span>.age = arg.age;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>타입 정의 사이에 껴있는 <code>|</code> 연산자가 보이는가? 쉽게 예상할 수 있겠지만 해당 연산자는 OR를 의미하며, 따라서 <code>arg</code>라는 매개변수는 <code>number</code> 타입 혹은 <code>Person</code> 타입이 될 수 있다. 생성자 내부에서 타입 검사를 해서 오버로딩을 할 수 있을 것이다. 나머지 타입을 통해 호출하게 되면 에러를 발생 시킨다.</p>
<p>그러나 이 방법은 여러모로 구린 해결책이라고 생각한다. 그 이유는 첫 번째, 원래 컴파일러에게 위임했던 타입 검사를 다시 런타임에서 해야한다. 그게 뭐 대수냐 할 수 있겠는데, 결국 TypeScript를 사용하는 이유 중 가장 큰 게 컴파일 타임의 타입 체크 아닌가? TypeScript 자체의 사용 의미가 퇴색될 수 있다. 두 번째, 매개변수의 식별자를 <code>arg</code>처럼 의미없는 이름으로 짓게 된다. 왜냐하면 어떤 타입이 들어오는지 알기 어렵기 때문에 결국 그 매개변수가 가진 의미도 모를 수 밖에 없기 때문이다. 세 번째, 조건문 반복으로 코드의 깔끔함이 저하된다. 네 번째, 함수 내부에서 명시적인 형변환이 필요하다. 마지막을 제외하고는 JavaScript에서 오버로딩을 구현할 때 생기는 단점이고, 결국, JavaScript로 구현한 것과 별반 차이가 없게 된다. (컴파일까지 해야하는데도!)</p>
<p>Java 등의 정적 타입 언어에 익숙한 프로그래머가 아니더라도, 이쯤 되면 대체 왜 TypeScript의 함수 오버로딩이 이따구로 생겨먹게 되는지 의문을 품게 된다. (내가 그랬다) 이유는 간단하다. TypeScript가 정적 타입 언어라고 한들, 결국 동적 타입 언어인 JavaScript로 컴파일 될 것이기 때문이다. TypeScript에서는 타입에 따라 다른 함수로 분류하더라도, JavaScript로 컴파일 되면서 식별자가 같으므로 다른 종류의 인자를 받는 동일한 함수가 되기 때문에 뒤에 구현된 함수가 앞에 구현된 함수를 덮어쓰게 될 것이다. 물론, TypeScript는 인자의 갯수나 타입이 다른 경우에도 동일한 식별자를 가진 메소드를 허용하지 않으므로 컴파일 자체가 불가능하지만, 애초에 이유를 따져보자면 그랬을 것이라는 것이다. <a href="https://kwangyulseo.com/2015/06/08/typescript-function-overloads/" target="_blank" rel="external">이 링크</a>에서 잘 설명하고 있기 때문에 참조를 추천한다.</p>
<p>뭐 어쨌든, TypeScript에서는 공식적으로 이 방법으로 함수를 오버로딩할 수 있다고 안내하고 있기 때문에, 다른 방법이 없는 현재로선 이렇게라도 써야할 듯 하다.</p>
<h2 id="Default-Parameter"><a href="#Default-Parameter" class="headerlink" title="Default Parameter"></a>Default Parameter</h2><p>Default Paramter는 기본 매개변수. 이 쪽은 이미 ES2015에 도입된 바 있다. JavaScript에서 매개변수로 넘겨받는 값의 디폴트 값을 설정해주고 싶었다면 보통 다음과 같이 할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">whatever</span>) </span>&#123;</div><div class="line">  whatever = whatever || <span class="string">'whatever'</span>; <span class="comment">// Set default value</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TypeScript와 ES2015에서는 이렇게 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">whatever = <span class="string">'whatever'</span></span>) </span>&#123; <span class="comment">// Set default value</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TypeScript에서는 Default 값을 주는 경우에는 타입을 선언하지 않아도 인자의 타입을 추론하므로 선언을 생략해도 무방하다.</p>
<h2 id="Rest-Parameter"><a href="#Rest-Parameter" class="headerlink" title="Rest Parameter"></a>Rest Parameter</h2><p>Rest Parameter는 흔히 가변인자라고 표현한다. ES5까지의 JavaScript에서는 <code>arguments</code>라는 글로벌 변수를 통해 접근할 수 있었다. <code>this</code>와 마찬가지로 글로벌 변수이면서도 컨텍스트에 따라 값이 달라지기 때문에, 좋은 방법이 아니라는 사실은 이미 알고 있을 것이다. ES2015부터는 <code>...</code>이라는 표기법을 통해 추가적인 인자들에 접근할 수 있게 되었다. 물론 ES2015를 확장한 TypeScript도 마찬가지다.</p>
<p>Rest Parameter를 통해 인자의 갯수가 추가로 몇 개가 들어오던지 처리할 수 있다. 함수 오버로딩에도 사용할 수 있지만 일반적으로는 함수 오버로딩을 하기위해 Rest Paramter를 사용하지는 않을 것이다. ES2015 스펙이므로 깊게 다루지 않고 넘어가겠다.</p>
<h2 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a><code>noImplicitThis</code></h2><p>JavaScript에서 <code>call</code> 혹은 <code>apply</code>, <code>bind</code> 등을 이용해서 <a href="/2016/03/10/javascript-this/"><code>this</code>에 원하는 값을 바인딩하는 패턴</a>은 잘 알려져있고 실제로도 자주 사용되는 방법이기도 하다. 지금까지 TypeScript에서 이런 패턴을 사용하는 데에는 약간의 문제가 있었는데, 바로 함수 내부에서 <code>this</code>의 타입을 알 수가 없다는 점이었다.</p>
<p>TypeScript는 2.0 버전부터 이를 다루기 위해서 <code>noImplicitThis</code>라는 옵션을 제공하고 있다. 이 옵션을 사용하면 함수 내부에서 <code>this</code>를 다뤄야 할 경우, 매개변수 목록에 <code>this</code>와 그 타입을 선언해야 한다. 예를 들어, 아래와 같은 함수가 있다고 가정하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="keyword">this</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">logArray.call([<span class="string">'팔랑이'</span>, <span class="string">'쭈쭈'</span>]);</div></pre></td></tr></table></figure>
<p>JavaScript에서는 문제없는 함수다. 하지만 TypeScript에서 <code>noImplicitThis</code>를 <code>true</code>로 설정하고 컴파일하면 <code>&#39;this&#39; implicitly has type &#39;any&#39; because it does not have a type annotation.</code> 라며 오류가 발생한다. 함수 내부에서 <code>this</code>가 어떤 값이 될지 모르니 <code>any</code> 타입이라고 가정하게 되는 것이다. 이 경우 타입 선언은 아래와 같이 할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArray</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">string</span>[]</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item of <span class="keyword">this</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">logArray.call([<span class="string">'팔랑이'</span>, <span class="string">'쭈쭈'</span>]); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>원래 매개변수가 없었음에도 위와 같이 <code>this</code>라는 매개변수를 선언해 줄 수 있다. 참고로 JavaScript에서 <code>this</code>를 매개변수에 넣어서 선언하면 <code>Unexpected Token</code>에러가 발생한다. 즉, 저 구문은 TypeScript에서 타이핑을 할 때만 쓰이고, 컴파일되면서 삭제되는 구문이다. 당연하지만 <code>call</code>이든 <code>apply</code>든 써서 <code>this</code>값을 바인딩 할 때, 선언한 타입과 맞지 않는 값을 넣으면 에러가 발생한다.</p>
<p>클래스에서는 당연히 <code>this</code>의 사용빈도가 매우 높기에 저 옵션을 준 뒤 <code>this</code>를 선언하지 않아도 에러가 나지는 않는다. 하지만 동시에, <code>this</code>를 선언해도 에러가 나지 않는다. 오히려, 클래스에서도 <code>this</code> 선언을 권고하는 것도 괜찮은 방법이라고 생각한다. 마치 Python에서 <code>self</code>가 항상 클래스 메소드의 첫 번째 매개변수가 되는 것처럼.(명시적인 것이 묵시적인 것보다 낫다) 그러나 <code>constructor</code>에서는 <code>this</code> 선언 시 에러가 발생하기 때문에 애매한 부분이 있다.</p>
<p>다음 글 - <a href="/2017/01/14/typescript-generic/">TypeScript: 제네릭(Generic)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/10/17/typescript-interface&quot;&gt;TypeScript: 인터페이스(Interface)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;함수-타입-선
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Deview 2016 1일차 정리</title>
    <link href="https://hyunseob.github.io/2016/11/07/deview-2016/"/>
    <id>https://hyunseob.github.io/2016/11/07/deview-2016/</id>
    <published>2016-11-07T14:19:38.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="https://scontent.cdninstagram.com/t51.2885-15/e35/14723667_765434476928254_3130109969903386624_n.jpg"/><h2 id="키노트"><a href="#키노트" class="headerlink" title="키노트"></a>키노트</h2><p>키노트에서는 네이버 랩스에서 진행하고 있는 신기술 개발 발표에 많은 시간을 할애했다. 크게 세 가지 기술이 소개됐다.</p>
<h3 id="WHALE"><a href="#WHALE" class="headerlink" title="WHALE"></a>WHALE</h3><p>첫 번째는 네이버의 새로운 웹 브라우저 <a href="http://whale.naver.com/" target="_blank" rel="external">WHALE</a>, 이전부터 네이버 정도면 자체 브라우저 만들어볼만한데 왜 하지 않을까라는 의문이 약간 있었는데, 역시나 개발중이었다. 여러가지 기능들도 같이 소개됐는데 솔직히 Killing feature는 없다는 느낌이다. 그러나 좋은 시도다. 이전에도 이스트소프트에서 만든 스윙브라우저 등 한국에서 자체 개발한 브라우저가 없는 것은 아니었지만 솔직히 방향은 약간 엇나간 느낌이 있었다. ActiveX를 지원하려고 한다던지 하는.. 뭐 WHALE도 까봐야 알겠지만 크게 이상한 방향으로 흘러갈 것 같지는 않다. 일단 네이버니까 어느 정도는 신뢰가 된달까. 다만 커스텀 V8 엔진을 쓴다고 하는데 그 커스텀이 웹 개발자로서 조금 신경쓰인다. 파파고의 번역 엔진이 결합된 번역 기능은 꽤나 도움이 될 거 같다. 구글 번역에 비해 파파고의 번역이 월등한 품질을 보여주기 때문에 기대가 된다.</p>
<h3 id="Amica"><a href="#Amica" class="headerlink" title="Amica"></a>Amica</h3><p>두 번째는 Amica라는 녀석으로 쉽게 말해 Siri같은 음성인식 인공지능이다. 아미카는 단순히 음성인식을 넘어서 Ambient Intelligence(생활환경지능)를 지향한다고 한다. 발화자의 문맥을 이해하겠다는 취지다. 티저 영상만 봤을 때는 뭐 거의 대적할 상대가 없을 정도로 다재다능, 완벽한 모습이었지만 실제로 그 수준은 당연히 아닐 거라고 생각한다.이것도 까봐야 알듯하다. 아미카는 동시에 Amica.ai라는 기술도 공개했다. 구체적인 스펙에 대해서는 알 수 없지만 네이버의 대화 자연어 처리 기술 API정도로 유추할 수 있다. 이걸 기반으로 Amica라는 인공지능을 개발하고 기반 기술을 공개한 것이다. 사실 한국어 자연어 처리에 있어서는 네이버가 1인자이기 때문에 한국어 기반 챗봇을 만든다면 이만한 API가 있을까 싶다.</p>
<h3 id="M1"><a href="#M1" class="headerlink" title="M1"></a>M1</h3><p>세 번째는 M1이라는 이름을 가진 실내 공간 정보를 데이터로 매핑하는 로봇이었다. 사실 이 로봇보다 놀라웠던 건 네이버도 자율주행기술을 개발중이라는 사실이었다. 로봇자체는 신기하긴 했지만 나로서는 크게 흥미롭지는 않았다.</p>
<p>이보다 자세한 내용은 <a href="http://www.bloter.net/archives/266182" target="_blank" rel="external">블로터</a>에서 확인할 수 있다.</p>
<h2 id="Web-Payment-API의-현재와-미래"><a href="#Web-Payment-API의-현재와-미래" class="headerlink" title="Web Payment API의 현재와 미래"></a>Web Payment API의 현재와 미래</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/sxjAvK4zspLEUs" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>

<p><a href="https://w3c.github.io/browser-payment-api/" target="_blank" rel="external">Web Payment API</a>는 W3C에서 새롭게 만들고 있는 웹 결제 기술이다. 지금까지는 쇼핑몰이나 결제 업체측에서 제공하던 결제 인터페이스를 브라우저에서 제공하는게 주요 골자다.</p>
<p>지원하는 브라우저는 사실상 크롬과 삼성 브라우저 밖에 없는 단계로 아직은 지원률이 좀 많이 낮긴하지만 제대로 지원만 된다면 앞으로는 새로운 웹사이트를 개발하는 때 결제관련 처리의 공수가 많이 줄어들 것으로 예상된다. 인터페이스를 브라우저에서 제공하므로, 인터페이스를 디자인 하거나 마크업할 필요도 없을 뿐더러, 근미래에 구현되어있는 브라우저에서는 모두 인터페이스를 제공할 것이므로 크로스 브라우징을 신경쓸 필요도 없겠다. 물론 IE를 버린다는 전제하에..(-_-;) 뭐 사실상 이걸 서비스에 도입하려면 최소한 1~2년 정도는 기다려야 될 것같다. 아직 모던 브라우저 조차 지원하지 않는데..</p>
<p>Web Payment API는 Payment App이라는 별도의 모듈도 포함할 수 있는데, Payment App이란 익히 우리가 알고 있는 삼성 페이, 애플 페이같은 서드파티 결제 서비스를 말한다. 물론 지금 바로 사용할 수 있는 건 아니고, 이 서비스들이 Web Payment API를 대응해야 한다.</p>
<p>발표에서는 <a href="https://www.w3.org/TR/service-workers/" target="_blank" rel="external">Service Worker</a>를 기반으로 Payment App을 구현하는 방법을 소개했다. Service Worker도 현재 Working draft 단계에 있는 기술인데, 생명주기가 일반 JavaScript 어플리케이션과는 달라, Document가 닫히더라도 살아있을 수 있다. 브라우저 지원률은 현재 크롬과 파이어폭스 정도만 지원하는 단계다. 나도 몇 번 들어보기만 했지 잘 아는 기술은 아니라 자세한 설명은 <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers#lifecycle" target="_blank" rel="external">링크</a>로 대체한다.</p>
<h2 id="REST에서-GraphQL과-Relay로-갈아타기"><a href="#REST에서-GraphQL과-Relay로-갈아타기" class="headerlink" title="REST에서 GraphQL과 Relay로 갈아타기"></a>REST에서 GraphQL과 Relay로 갈아타기</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/gw1x7HAmdm0AVD" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>

<p>요즘에 GraphQL에 대한 언급이 많은데, 뭔지도 잘 모르고 해서 선택한 세션이다. REST를 대체하겠다는 말도 조금 걸렸고..</p>
<p>REST는 익히 알고있겠지만, 지금까지 웹 서버에서 가장 권장되었던 서버 인터페이스 스타일이었다. 설계를 잘하면 이해도 쉽고 보기좋은 URI를 사용해서 인터페이스를 구성할 수 있지만, 기본적인 프로토콜, HTTP method와 URI만을 이용하여 설계하므로 한계점도 명확하다. 발표에서는 크게 중구난방의 설계 방식이나, 데이터 타입, Query Hell, 라이브러리 부족 등을 한계로 꼽았다.</p>
<p>GraphQL은 이런 한계점을 깨트리기 위해 나온 쿼리 언어다. 코드를 보니 확실히 표현력이 좋다는 생각이 들었다. 애초에 목적 자체가 모던 어플리케이션을 위한 서버 인터페이스 설계이기 때문에 위에서 REST의 단점으로 꼽은 것들을 제외하고도 부자연스러웠던 것들을 심플하고 우아하게 해결할 수 있는 것 같았다.</p>
<p>GraphQL의 특성상 클라이언트에서 HTTP Request를 래핑해야 하는데, 어차피 요즘에는 클라이언트에서 HTTP Request를 래핑하는 일은 흔하기 때문에 단점으로 꼽기는 어려울 것 같다. 나는 GraphQL이 거기에 여러가지 추상화를 더한 것이라고 생각한다.</p>
<p>약간 의문점도 있는데, GraphQL을 위해서 Schema를 정의하게 된다면 데이터베이스 스키마와 중복되는 거 아닌가하는 생각이 든다. 내가 잘못생각하는 것일 수도 있지만.</p>
<p>Relay를 사용하면 React와의 연결 또한 긴밀하게 수행할 수 있다고 한다. 내가 React에 대해서 잘 알지 못해서 Relay에 대해서는 특별히 코멘트하지 않으려고 한다.</p>
<h2 id="Electron-웹-개발자들을-위한-Desktop-Application-제작"><a href="#Electron-웹-개발자들을-위한-Desktop-Application-제작" class="headerlink" title="Electron : 웹 개발자들을 위한 Desktop Application 제작"></a>Electron : 웹 개발자들을 위한 Desktop Application 제작</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/75U2vMY8exKgH8" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>

<p>이번 세션은 내가 일하고 있는 Studio XID에서 발표를 맡은 세션이다. 발표는 CTO님이 해주셨다.</p>
<p>Electron은 웹 개발에서 사용되는 언어를 통해 데스크탑 어플리케이션을 개발할 수 있는 도구다. GitHub에서 발표하였으며 Slack이나 Atom, Visual Studio Code 같은 어플리케이션도 Electron을 이용하여 개발되었다. 물론, StudioXID에서 개발하고 있는 <a href="https://protopie.io" target="_blank" rel="external">ProtoPie</a> 역시 Electron 기반의 어플리케이션이다.</p>
<h3 id="Event-based-Asyncronous-Pattern"><a href="#Event-based-Asyncronous-Pattern" class="headerlink" title="Event-based Asyncronous Pattern"></a>Event-based Asyncronous Pattern</h3><p>Electron으로 개발된 어플리케이션은 기본적으로 소스를 까볼 수 있다. ProtoPie는 서비스가 아니라 툴이기 때문에 소스가 공개되면 치명적일 수 있으므로 소스를 최대한 숨기는 것이 당면과제였다. ProtoPie는 주요 비즈니스 로직을 숨기기 위해서 대부분의 비즈니스 로직을 백엔드에서 처리하고 백엔드를 바이너리로 빌드하여 해결했다.</p>
<p>이 때문에 백엔드에서는 비즈니스 로직을 처리하고 클라이언트에서는 이벤트만 받아 처리하는 Event-based Asyncronous 패턴을 사용하게 되었다.</p>
<h3 id="Command-Pattern"><a href="#Command-Pattern" class="headerlink" title="Command Pattern"></a>Command Pattern</h3><p>데스크탑 어플리케이션이기 때문에 유저는 당연히 Undo, Redo가 될 것이라고 예상하고 그게 되어야 유저가 편리한 것도 당연하다. 클라이언트는 View에 집중하고 유저의 커맨드를 서버에 전달하게 되며, 서버에서 이를 처리하게 된다. 이 때 유저의 모든 동작은 Undo Redo가 가능한 Command로 추상화하고 CommandQueue로 관리된다.</p>
<h3 id="Front-End-Framework"><a href="#Front-End-Framework" class="headerlink" title="Front-End Framework"></a>Front-End Framework</h3><p>이건 개인적인 코멘트인데, 앞서 말한 사항들을 보면 모던 웹 개발과는 많은 부분이 다르다는 걸 알 수 있다. 점점 비즈니스 로직을 프론트 쪽으로 옮기고 있는 추세와는 달리 ProtoPie는 백엔드 쪽으로 옮기고 있다. 따라서 프론트엔드 프레임워크의 필요성 자체가 낮다. (그래도 View에다 그냥 React 정도는 써볼만 하지 않을 까 싶다)</p>
<p>대신, Electron 기반으로 하므로 크로스 브라우징을 고려할 필요가 없어 크로미움이 지원하는 만큼 ECMAScript를 충분히 사용할 수 있기 때문에 프레임워크 없이도 어느 정도는 개발자 입장에서도 어렵지 않은 개발을 할 수 있다. 여기에 ProtoPie는 TypeScript를 사용하여 안정성도 확보하였다.</p>
<h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>먼저 백엔드 코드를 숨겨야하기 때문에 Node.js 바이너리 빌드가 가능한 EncloseJS라는 유료 라이브러리를 사용하게 되었다. 문서화가 좋지 않은 상태지만 피드백은 괜찮다고 한다.</p>
<p>빌드는 Electron builder를 사용한다.</p>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><p>유저는 업데이트를 싫어하기 때문에 강제로 업데이트를 시켜야 한다. 그래서 백그라운드에서 업데이트를 하는 Auto update가 제공된다.</p>
<p>또한 CDN을 사용해서 업데이트가 매우 느린 지역을 커버했다.</p>
<h2 id="Angular2-VS-React"><a href="#Angular2-VS-React" class="headerlink" title="Angular2 VS React"></a>Angular2 VS React</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/1Ru6BcWHvxZ7nc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>

<p>제목부터 대놓고 “이거 궁금해 죽겠지? 듣고싶지? 재밌겠지?” 말하는 거 같아서 나에게 다른 선택권 따위는 없었다. 사실 둘 다 그리 익숙한 프레임워크는 아니지만 개인적으로는 Angular은 프로덕션 경험도 있고 지금도 TypeScript를 시작으로 Angular2를 공부하는 중이고 해서 여전히 흥미로운 주제다.</p>
<p><img src="https://pbs.twimg.com/media/CvgqGI5VYAAtpFJ.jpg" alt="Angular2 VS React"></p>
<p>시작하기 전 투표하는 공간이 있었는데 나는 Angular에 투표했다 ㅋㅋ 어쨌든 Angular2에 더 호감이 있는 쪽이라서 글 내용이 사실 편파적일 수도 있다(…)</p>
<h3 id="언어-생산성"><a href="#언어-생산성" class="headerlink" title="언어 생산성"></a>언어 생산성</h3><p>소제목의 이름은 언어 생산성이지만 사실상 TypeScript 갑론을박이었던 것 같다. React의 경우에는 특별히 JavaScript가 아닌 다른 언어랑 사용하는 케이스가 높지 않다고 한다. 발표에서는 Flow를 언급하였는데, React는 Flow랑 같이 사용하는 비율이 4%도 채 안된다고. 반면에 Angular2는 TypeScript로 구현되었으며 TypeScript를 기본적으로 추천한다.</p>
<p>나도 TypeScript를 배우고, 쓰고 있지만 당연히 트레이드오프가 있는 기술이다. 발표에서 지적된 것은 기본적으로 JavaScript 외부 모듈을 갖다쓰게 될텐데, 모듈 인터페이스 정의 비용이 있다는 것이었다. 뭐 실제로 개발해보니 대부분 typings를 통해 정의가 잘 되어있었고, 꼭 외부 인터페이스를 사용하기 위해 <code>any</code>를 사용해서 코딩해야하는 경험은 아직까지 갖지 못했다. 발표 때 언급된 것처럼 공부하기는 어렵지만, JavaScript의 미래라고 생각한다면 투자비용으로 볼 수 있다는 것에도 동의한다.</p>
<h3 id="컴포넌트"><a href="#컴포넌트" class="headerlink" title="컴포넌트"></a>컴포넌트</h3><p>이쪽은 주로 JSX에 대한 갑론을박이 많이 벌어졌던 것 같다. 먼저 Angular2에서는 HTML, CSS, JS를 통합해 컴포넌트를 만들기 때문에 한데 묶어 캡슐화 할 수 있다. 반면 React의 경우에는 컴포넌트 단위의 CSS를 지원하지 않으며 JSX라는 언어를 사용하는 방식으로 HTML을 통합한다.</p>
<p>JSX를 사용하면 JavaScript파일에서 마크업도 같이 가져가게 되므로 마크업 개발자와의 협업에 문제가 생긴다는 지적이다. 하지만 Angular2도 순수한 HTML이 아니므로 협업에 문제가 있다는 것이 동일하다는 내용이 있었다. 나는 마크업 개발자와 협업을 해본 경험이 없는데, 사실 이런 프레임워크를 쓰게 된다면 HTML과 CSS만 다룰 수 있는 마크업 개발자와는 협업하기 어려울 것 같다는 생각이 들기는 한다. 따라서 나는 요즘에 프론트엔드 개발자가 마크업까지 책임을 져야한다고 생각한다.</p>
<p>JSX에 대해 말하자면, 나는 큰 거부감은 없으나 발표때 언급된 것처럼 <code>className</code>같은 건 좀 꺼림칙하다. 그렇지만 이건 그냥 취향일 뿐이지 절대로 큰 문제는 아니라고 생각한다. 그리고 요즘에는 JSX처럼 구조와 로직을 함께 가져가는 것도 이제는 오히려 자연스러워 보인다. Angular에서도 전부터 <code>ng-repeat</code>처럼 일종의 프로그래밍 로직이 포함되었기 때문에 결국 구조와 로직이 섞이는 건 프론트엔드 개발에서는 피할 수 없는 문제라고 본다.</p>
<h3 id="데이터-동기화"><a href="#데이터-동기화" class="headerlink" title="데이터 동기화"></a>데이터 동기화</h3><p>데이터 바인딩에 대해서 말하는 세션이었다. 먼저 Angular1의 양방향 데이터 바인딩을 까고 시작하며, React의 단방향 데이터 플로우에 대한 설명이 이어졌다. Angular1은 디폴트로 양방향 데이터 바인딩을 지원하기 때문에 성능상으로도 React에 밀렸고, 데이터 흐름도 복잡했던 것이 사실이다. 따라서 이런 과오를 인정하고 Angular2에서는 디폴트 바인딩이 단방향으로 바뀌었다.</p>
<p>덧붙여 <a href="https://github.com/angular/zone.js/" target="_blank" rel="external">Zone.js</a>라는 것이 소개되었다. Angular에서 새롭게 도입한 라이브러리인데, 나도 정확히 이해하지는 못하고 있지만 이 라이브러리를 통해 Angular2에서는 더 이상 비동기 동작 이후에도 명시적으로 동기화를 수행해 줄 필요가 없다는 것이 언급되었다.</p>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a href="http://sculove.github.io/blog/2016/07/11/react%EB%B3%B4%EB%8B%A4-angular2%EC%97%90-%EB%8D%94-%EC%A3%BC%EB%AA%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/" target="_blank" rel="external">React보다 Angular2에 더 주목해야하는 이유</a> - 발표자인 손찬욱님이 쓴 글이고, 발표내용이 Angular2 입장에서 잘 녹아들어가 있다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>작년 Deview는 내 내공이 부족해서 그랬던 건지 몰라도 별로 기억에 남았던 것이 없었다. 이번 Deview는 1일 차에 웹 관련 기술을 집중적으로 몰아넣은 것 같은데, 덕분에 작년보다는 훨씬 즐겁게 관람했다. (2일 차는 예비군으로 빠짐 ㅠㅠ) 안타깝게도 행사 막바지 졸음이 쏟아져 마지막으로 들어갔던 Clean FE Development 세션은 거의 듣질 못해서 정리할 내용이 없다. 물론 발표자료는 남아있기 때문에 이 링크에서 <a href="http://www.slideshare.net/deview/115-clean-fe-development" target="_blank" rel="external">감상</a>하면 되겠다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://scontent.cdninstagram.com/t51.2885-15/e35/14723667_765434476928254_3130109969903386624_n.jpg&quot;/&gt;&lt;h2 id=&quot;키노트&quot;&gt;&lt;a href=&quot;#키노트&quot;
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Deview" scheme="https://hyunseob.github.io/tags/Deview/"/>
    
      <category term="Log" scheme="https://hyunseob.github.io/tags/Log/"/>
    
      <category term="GraphQL" scheme="https://hyunseob.github.io/tags/GraphQL/"/>
    
      <category term="Electron" scheme="https://hyunseob.github.io/tags/Electron/"/>
    
      <category term="Angular2" scheme="https://hyunseob.github.io/tags/Angular2/"/>
    
      <category term="React" scheme="https://hyunseob.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 인터페이스(Interface)</title>
    <link href="https://hyunseob.github.io/2016/10/17/typescript-interface/"/>
    <id>https://hyunseob.github.io/2016/10/17/typescript-interface/</id>
    <published>2016-10-16T17:41:45.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/10/17/typescript-class">TypeScript: 클래스(Class)</a></p>
<h2 id="클래스와-인터페이스"><a href="#클래스와-인터페이스" class="headerlink" title="클래스와 인터페이스"></a>클래스와 인터페이스</h2><p>지금껏 JavaScript만을 다뤄본 개발자라면 인터페이스라는 개념은 익숙치 않을 것이다. 하지만 Java나 C# 등의 정적 타입 언어에서는 이미 많이 쓰이는 개념이다. 인터페이스는 클래스에서 구현부가 빠졌다고 이해하면 편하다. 즉, 어떠한 객체가 이러이러한 프로퍼티 혹은 메소드를 가진다고 선언하는 것이다. 실질적인 구현은 이를 구현한다고 선언하는 클래스에 맡긴다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">  getArea(): <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Rect <span class="keyword">implements</span> Shape &#123;</div><div class="line">  width : <span class="built_in">number</span>;</div><div class="line">  height: <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width, height</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width  = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// error: Class 'Rect' incorrectly implements interface 'Shape'. Property 'getArea' is missing in type 'Rect'.</span></div></pre></td></tr></table></figure>
<p>위의 코드에서는 <code>Rect</code>라는 클래스가 <code>implements</code> 키워드를 통하여 <code>Shape</code>라는 인터페이스를 구현할 것이라고 선언하는 것이다. 일단 인터페이스를 구현하기로 했으면, 해당 인터페이스에 있는 프로퍼티 및 메소드를 전부 가지거나 구현해야 한다. 여기에서는 <code>getArea</code>라는 메소드를 구현하지 않았으므로 에러가 발생한 모습이다.</p>
<h2 id="덕-타이핑-Duck-typing"><a href="#덕-타이핑-Duck-typing" class="headerlink" title="덕 타이핑(Duck typing)"></a>덕 타이핑(Duck typing)</h2><p>동적 타이핑 중에서 <a href="https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91" target="_blank" rel="external">덕 타이핑</a>이라는 것이 있다. JavaScript는 동적 타입 언어이므로 이 개념을 활용해서 코딩하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</div><div class="line">  quack() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'꽥!'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  quack() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'나도 꽥!'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSomeNoiseWith</span>(<span class="params">duck</span>) </span>&#123;</div><div class="line">  duck.quack();</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeSomeNoiseWith(<span class="keyword">new</span> Duck()); <span class="comment">// OK</span></div><div class="line">makeSomeNoiseWith(<span class="keyword">new</span> Person()); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>만약 위와 같은 상황에서 <code>Person</code> 클래스에 <code>quack</code> 메소드가 구현되어 있지 않으면 어떻게 될까? 바로 런타임 에러를 발생시키며 프로그램이 종료될 것이다. 이와 같은 런타임 에러를 방지하기 위해서 메소드를 실행시키기 전에 검사할 수도 있지만 코드가 너무 장황해져 덕 타이핑의 장점이 사라진다.</p>
<p>TypeScript에서는 인터페이스를 활용하면 덕 타이핑을 할 때 메소드를 검사하지 않고도 런타임 에러를 막을 수 있다. TypeScript의 덕 타이핑은 어떤 객체가 특정 인터페이스에서 명시하는 메소드를 가지고 있다면 해당 객체가 그 인터페이스를 구현한 것으로 보는 것이다. 설명이 너무 장황하므로 코드 예제를 잠깐 보자.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> Quackable &#123;</div><div class="line">  quack(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Duck <span class="keyword">implements</span> Quackable &#123;</div><div class="line">  quack() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'꽥!'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">  quack() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'나도 꽥!'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSomeNoiseWith</span>(<span class="params">duck: Quackable</span>): <span class="title">void</span> </span>&#123;</div><div class="line">  duck.quack();</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeSomeNoiseWith(<span class="keyword">new</span> Duck()); <span class="comment">// OK</span></div><div class="line">makeSomeNoiseWith(<span class="keyword">new</span> Person()); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p><code>Duck</code> 클래스는 명시적으로 <code>Quackable</code> 인터페이스를 구현한다고 선언하였으므로 <code>Quackable</code> 객체만 인자로 받는 <code>makeSomeNoiseWith</code>에 인자로 넘겨지는 것이 이상하지 않다. 그러나 <code>Person</code> 클래스는 조금 이상하다. 분명 <code>Quackable</code> 인터페이스를 구현한다고 선언하지 않았지만 문제없이 인자로 넘어간다.</p>
<p>이게 아까 말한대로 TypeScript에서의 덕 타이핑이다. 그냥 <code>Quackable</code>에서 명시했던 <code>quack</code> 메소드만 구현되어 있다면 <code>Quackable</code> 객체로 보는 것이다. <code>Person</code> 클래스에서 <code>quack</code> 메소드를 제거하면 컴파일 에러가 난다. 개발자는 런타임에 메소드 검사를 하지 않고도 런타임 에러를 방지할 수 있다.</p>
<p>물론 조금 더 strict하게 타이핑을 하고 싶다면 <code>implements</code> 키워드를 사용하여 명시적으로 선언해주는 것도 여전히 좋은 방법이다. 참고로, <a href="http://www.popit.kr/golang%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%B3%B4%EB%8A%94-duck-typing/" target="_blank" rel="external">Go에서도 이와 유사한 방식의 덕 타이핑</a>을 활용할 수 있다. 이런 방식의 덕 타이핑은 <em>구조적 타이핑(Structural typing)</em> 이라고도 한다. 기회가 되면 덕 타이핑을 더 자세히 다뤄보는 포스트를 작성하도록 하겠다.</p>
<h2 id="Optional-프로퍼티"><a href="#Optional-프로퍼티" class="headerlink" title="Optional 프로퍼티"></a>Optional 프로퍼티</h2><p>인터페이스는 클래스와 매우 흡사한 모습을 가지고 있지만 주 용도는 다르다. 인터페이스로는 객체 인스턴스를 생성할 수 없으므로 주로 타입 검사를 위해서 활용된다. ES2015에 클래스는 있지만 인터페이스는 없다는 것이 그 사실을 방증한다. 그 차이가 Optional 프로퍼티에서 잘 드러난다. 인터페이스의 모든 프로퍼티 및 메소드는 구현하는 클래스에서 기본적으로 가지고 있어야 될 것들이지만, Optional 프로퍼티는 말 그대로 선택적으로 구현하는 프로퍼티다. 프로퍼티 식별자 뒤에 간단하게 <code>?</code>를 붙여서 사용한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">  width? : <span class="built_in">number</span>;</div><div class="line">  height?: <span class="built_in">number</span>;</div><div class="line">  radius?: <span class="built_in">number</span>;</div><div class="line">  getArea(): <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Rect <span class="keyword">implements</span> Shape &#123;</div><div class="line">  width : <span class="built_in">number</span>;</div><div class="line">  height: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width, height</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width  = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea(): <span class="built_in">number</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Circle <span class="keyword">implements</span> Shape &#123;</div><div class="line">  radius: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">radius</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.radius = radius;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea(): <span class="built_in">number</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius * <span class="keyword">this</span>.radius;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드에서 알 수 있듯이, 인터페이스를 구현하는 클래스에서는 Optional 프로퍼티를 가지고 있지 않더라도 에러가 발생하지 않는다.</p>
<h2 id="Indexable"><a href="#Indexable" class="headerlink" title="Indexable"></a>Indexable</h2><p>JavaScript의 객체는 프로퍼티 접근자(Property accessor)를 두 가지 제공한다. 하나는 점 표기법(Dot notation)이고, 다른 하나는 괄호 표기법(Bracket notation)이다. 기본적으로 점 표기법을 자주 사용하기는 하지만, 동적으로 프로퍼티에 접근하려는 경우 문자열으로 프로퍼티에 접근할 수 있는 괄호 표기법을 사용하기도 한다.</p>
<p>그러나 TypeScript는 괄호 표기법으로 프로퍼티에 접근하려고 하면 애로사항이 꽃 핀다. 다음의 코드를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> dict = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(dict)</div><div class="line">.forEach(<span class="function"><span class="params">k</span> =&gt;</span> <span class="built_in">console</span>.log(dict[k]));</div></pre></td></tr></table></figure>
<p>예제가 조금 이상하긴 하지만 JavaScript 개발을 조금이라도 해봤다면 동적으로 프로퍼티에 접근하는 상황이 종종 있었을 것이다. JavaScript에서 이 코드는 정상적으로 동작한다. 그러나 TypeScript에서는 dict의 프로퍼티를 동적으로 접근하는 부분(<code>console.log</code> 인자 부분)에서 <code>error: Index signature of object type implicitly has an &#39;any&#39; type.</code> 이라는 에러가 나면서 컴파일이 되지 않는다.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> TypeScript가 괄호 표기법을 제공하지 않는 것은 아니지만, 동적인 키 값을 사용하게 되면 에러가 발생한다.</p>
<p>에러 원인은 간단하다. 어떤 타입의 프로퍼티에 접근하는 지 알 수 없기 때문에 리턴 값을 묵시적으로 <code>any</code> 타입으로 변환하므로 에러를 띄우는 것이다. 이를 해결하기 위해서는 <code>noImplicitAny</code> 값을 <code>false</code>로 바꾸던지, 객체 자체를 <em>Indexable</em> 하게 만드는 방법밖에 없다. 객체를 Indexable 하게 만드려면 인덱스 시그니처(Index signature)를 사용하면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> Indexable &#123;</div><div class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> dict: Indexable = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(dict)</div><div class="line">.forEach(k =&gt; <span class="built_in">console</span>.log(dict[k])); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>위에 새로 추가된 인터페이스 내부 <code>[key: string]: any</code>라는 문장이 바로 인덱스 시그니처다. 괄호 표현법과 함께 <code>string</code>으로 접근하게 되면 <code>any</code>타입의 무언가를 돌려줄 것이라는 의미다. 여기서는 묵시적으로 <code>any</code> 타입을 리턴하지 않으므로 에러가 발생하지 않는다. 하지만 키 값으로 <code>number</code>나 <code>Symbol</code> 같은 다른 타입을 넘기게 되면 다시 에러가 발생하기 때문에 마찬가지로 필요하다면 인덱스 시그니처를 정의해야 한다.</p>
<h2 id="함수-인터페이스"><a href="#함수-인터페이스" class="headerlink" title="함수 인터페이스"></a>함수 인터페이스</h2><p>TypeScript의 인터페이스는 함수의 인터페이스를 정의할 수도 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> numberOperation &#123;</div><div class="line">  (arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span>): <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> sum: numberOperation = (arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span>): <span class="built_in">number</span> =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> arg1 + arg2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> multiply: numberOperation = (arg1, arg2) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> arg1 * arg2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> toArray: numberOperation = (arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span>): <span class="built_in">any</span>[] =&gt; &#123; <span class="comment">// error: Type '(arg1: any, arg2: any) =&gt; any[]' is not assignable to type 'numberOperation'. Type 'any[]' is not assignable to type 'number'.</span></div><div class="line">  <span class="keyword">return</span> [arg1, arg2];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>문법은 식별자 없이, 받아야할 인자의 타입과, 리턴 타입만을 표기하면 된다. 쉽게 예상할 수 있겠지만, 이 인터페이스를 구현하는 함수는 반드시 정의했던 타입의 인자를 받아 정의했던 타입을 리턴해야만 에러없이 컴파일이 된다.</p>
<p><code>multiply</code>처럼, 정의했던 인터페이스대로 구현된 함수는 굳이 타입을 명시할 필요는 없다. 이상한 타입만 명시하지 않으면 된다. 여기서 이상한 타입이라 함은 <code>any</code>와 애초에 인터페이스에서 선언했던 <code>number</code>를 제외한 타입들을 말한다.</p>
<p>타입을 명시하지 않으면 함수를 실제로 사용할 때 인자로 이상한 타입을 넘겨도 될 것 같지만, 그렇게 하면 타입이 맞지 않아 에러가 뜬다.</p>
<h3 id="생성자-인터페이스"><a href="#생성자-인터페이스" class="headerlink" title="생성자 인터페이스"></a>생성자 인터페이스</h3><p>JavaScript에서 함수는 일급 시민이므로 다른 함수에 인자로 넘길 수 있다. 생성자도 마찬가지로 함수이므로 인자로 넘기는 것이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">cstr, name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cstr(name, age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(createAnimal(Dog, <span class="string">'팔랑'</span>, <span class="number">15</span>));</div><div class="line"><span class="built_in">console</span>.log(createAnimal(Cat, <span class="string">'쭈쭈'</span>, <span class="number">10</span>));</div></pre></td></tr></table></figure>
<p><code>createAnimal</code> 이라는 함수의 윤리적인 이슈에 대해서 다루기엔 너무 양이 길테니 일단 넘어가도록 하자. 이 예제는 그냥 JavaScript 코드인데 문제없이 잘 돌아간다. 간단한 예제지만 TypeScript에서 구현하기가 간단하지 않다. 가장 큰 문제는 <code>createAnimal</code>의 첫 번째 인자로 받는 생성자 함수의 타입을 어떻게 정의하냐는 문제다. 일단 생성자는 함수이니, <code>Function</code>으로 정의하면 될 거 같다. 한 번 시도해보자.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Dog &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cat &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">cstr: <span class="built_in">Function</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cstr(name, age); <span class="comment">// error: Cannot use 'new' with an expression whose type lacks a call or construct signature.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">createAnimal(Dog, <span class="string">'팔랑'</span>, <span class="number">15</span>);</div><div class="line">createAnimal(Cat, <span class="string">'쭈쭈'</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>하지만 위의 코드는 컴파일이 안된다. TypeScript에서는 <code>new</code>와 함께 일반 함수를 호출할 수 없기 때문이다. 따라서 TypeScript가 생성자로 인식할 만한 어떤 타입을 써주어야 한다. 이 때 <code>new</code>라는 키워드를 이용해서 생성자의 인터페이스를 정의할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  age : <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> AnimalConstructor &#123;</div><div class="line">  <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): Animal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Animal &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  age : <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> Animal &#123;</div><div class="line">  name: <span class="built_in">string</span>;</div><div class="line">  age : <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age  = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">cstr: AnimalConstructor, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cstr(name, age); <span class="comment">// OK</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">createAnimal(Dog, <span class="string">'팔랑'</span>, <span class="number">15</span>);</div><div class="line">createAnimal(Cat, <span class="string">'쭈쭈'</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>당연히 생성자는 그것으로 인해 생성된 객체 인스턴스와 다른 타입이다. 이 코드에서는 객체 인스턴스가 <code>Animal</code> 타입, 그리고 생성자는 <code>AnimalConstructor</code> 타입이다. <code>AnimalConstructor</code>는 <code>new</code>라는 키워드와 함께 함수 인터페이스 문법을 사용하는데 이것이 TypeScript에서 생성자를 정의하는 문법이다. 앞에 <code>new</code> 키워드가 들어간다는 걸 제외하면, 일반 함수 인터페이스 문법과 다른 점이 없다. 다만 <code>Animal</code> 타입을 리턴한다는 것을 명시적으로 선언해줘야 한다.</p>
<h2 id="하이브리드-타입"><a href="#하이브리드-타입" class="headerlink" title="하이브리드 타입"></a>하이브리드 타입</h2><p>하이브리드 타입은 함수이기도 하면서 객체이기도 한 인터페이스다. 예를 들면, jQuery의 <code>$</code>는 객체이기도 하면서 쿼리 셀렉터로 기능하기도 하는 함수이기도 하다. 이 경우에 jQuery의 인터페이스를 정의하면 다음과 같이 쓸 수 있을 것이다.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">interface</span> jQueryElement &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> jQueryInterface &#123;</div><div class="line">  (<span class="built_in">string</span>: query): jQueryElement;</div><div class="line">  each: <span class="built_in">Function</span>;</div><div class="line">  ajax: <span class="built_in">Function</span>;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 처럼 함수 인터페이스의 문법과 일반 인터페이스 프로퍼티의 문법을 함께 사용할 수 있다. 사용하려는 JavaScript 라이브러리가 jQuery처럼 함수이면서도 객체로 구현된 경우, 이런 형태로 인터페이스를 정의할 수 있을 것이다.</p>
<h2 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h2><p>TypeScript의 인터페이스는 위에 설명한 것 이외에도 많은 기능을 갖추고 있다. 먼저 인터페이스가 인터페이스를 <code>extends</code> 키워드를 통해 확장할 수 있으며, 인터페이스끼리 다중 상속도 가능하다. 또한 인터페이스를 통해 클래스도 확장이 가능하다. 이런 기능들은 굳이 예제를 들어 설명해야할 정도로 이해하기 어려운 기능은 아니므로 따로 지면을 할애하지는 않았다. <del>실은 좀 귀찮아서..</del></p>
<p>다음 글 - <a href="/2016/11/18/typescript-function">TypeScript: 함수(Function)</a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">컴파일 옵션 중 <code>noImplicitAny</code> 옵션을 <code>false</code>로 설정하는 경우 에러가 나지 않는다. 디폴트 값은 <code>true</code>이다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">단순히 예제일 뿐이므로 실제와는 다를 수 있다.</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/10/17/typescript-class&quot;&gt;TypeScript: 클래스(Class)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;클래스와-인터페이스&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 클래스(Class)</title>
    <link href="https://hyunseob.github.io/2016/10/17/typescript-class/"/>
    <id>https://hyunseob.github.io/2016/10/17/typescript-class/</id>
    <published>2016-10-16T17:41:31.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/10/02/typescript-basic-type">TypeScript: Basic Type</a></p>
<p>클래스는 JavaScript 생태계 속에서도 TypeScript에만 있는 개념이 아니다. CoffeeScript나 ES2015를 사용해봤다면 이미 클래스를 몇 번 쯤은 사용해보았을 것이다. 이 글에서는 ES2015의 클래스를 알고 있다는 전제하에 TypeScript의 클래스의 몇 가지 다른 부분들에 대해서만 설명한다.</p>
<h2 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h2><p>TypeScript의 클래스에서는 선언한 값만 객체의 프로퍼티 값으로 활용할 수 있다. 예를 들면,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 ES2015에서는 잘 돌아가는 코드이다. 또한 클래스의 프로퍼티를 정의하는 일반적인 방법이다. 하지만 이 코드는 TypeScript에서는 <code>Property &#39;width&#39; does not exist on type &#39;Rect&#39;.</code> 라는 에러를 뿜으며 돌아가지 않는다. 말 그대로 TypeScript에서는 <code>Rect</code> 클래스에 <code>width</code> 프로퍼티가 정의되지 않은 상태이기 때문이다. TypeScript에서 프로퍼티를 정의하기 위해서는 다음과 같이 써야한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Rect &#123;</div><div class="line">  width : <span class="built_in">number</span>;</div><div class="line">  height: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>클래스 내부에 위와 같이 타입과 함께 사용할 프로퍼티를 선언할 수 있다. 또한 생성자로 넘겨받는 인수도 타입 선언을 해주면 정상적으로 동작한다.</p>
<h3 id="Static-프로퍼티"><a href="#Static-프로퍼티" class="headerlink" title="Static 프로퍼티"></a>Static 프로퍼티</h3><p>ES2015에서는 클래스에 <code>static</code> 키워드를 제공하고 있다. 하지만, ES2015의 <code>static</code>은 메소드 전용으로, 프로퍼티에는 활용할 수 없는 키워드다. 다행히도 TypeScript에서는 <code>static</code> 키워드를 프로퍼티에도 활용할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Rect &#123;</div><div class="line">  width : <span class="built_in">number</span>;</div><div class="line">  height: <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">static</span> count: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width, height</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    Rect.count++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line"><span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">20</span>);</div><div class="line">Rect.count; <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h2 id="접근-제한자-Access-modifier"><a href="#접근-제한자-Access-modifier" class="headerlink" title="접근 제한자(Access modifier)"></a>접근 제한자(Access modifier)</h2><p>객체지향적으로 JavaScript를 사용하게 되면 늘 남는 아쉬움이 하나 있다. 바로 은닉화다. JavaScript에서는 접근 제한자를 지원하지 않기 때문에 기본적으로 프로퍼티에 대해 접근을 막을 수는 없다. 때문에 private 프로퍼티의 식별자의 맨 앞에 언더스코어(<code>_</code>)를 넣어줌으로써 이 변수가 private으로 사용된다는 컨벤션을 사용하곤 하지만, 역시 외부에서의 접근을 막을 수 없다는 점에서는 동일하다. 이 문제는 ES2015에서도 동일하다. 하지만 TypeScript는 접근 제한자를 제공하기 때문에 이 문제를 해결할 수 있다.</p>
<p>사용법은 간단하다. 프로퍼티 선언시에 접근 제한자로 사용될 수 있는 <code>private</code>, <code>public</code>, <code>protected</code> 같은 키워드를 같이 선언해주면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Rect &#123;</div><div class="line">  <span class="keyword">private</span> width : <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">private</span> height: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width, height</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea(): <span class="built_in">number</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line">rect.width; <span class="comment">// ERROR: Property 'width' is private and only accessible within class 'Rect'.</span></div></pre></td></tr></table></figure>
<p>기본적으로 접근 제한자를 사용하지 않는다면 모든 프로퍼티와 메소드는 <code>public</code>이다.</p>
<h3 id="생성자에서의-활용"><a href="#생성자에서의-활용" class="headerlink" title="생성자에서의 활용"></a>생성자에서의 활용</h3><p>생성자에서도 접근 제한자를 사용할 수 있다. 생성자로 넘겨지는 인수에 접근 제한자를 사용하게 되면 해당 클래스에 그 인수의 식별자 이름과 같은 식별자의 프로퍼티가 정의되고 넘겨진 값으로 할당된다. 예를 들면, 위의 코드는 아래와 같이 다시 쓸 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Rect &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> width: <span class="built_in">number</span>, <span class="keyword">private</span> height: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line"></div><div class="line">  getArea(): <span class="built_in">number</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line">rect.getArea(); <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>인자로 넘긴 <code>width</code>, <code>height</code> 값이 묵시적으로 객체 인스턴스 프로퍼티에 할당된 것을 알 수 있다.</p>
<h3 id="Readonly-제한자"><a href="#Readonly-제한자" class="headerlink" title="Readonly 제한자"></a>Readonly 제한자</h3><p>TypeScript에는 이외에도 <code>readonly</code>라는 특별한 제한자를 하나 제공한다. 이름에서 쉽게 유추할 수 있듯이 읽기만 가능한 프로퍼티를 선언할 때 사용된다. 쉽게 말해 프로퍼티를 위해 사용할 수 있는 <code>const</code>인 것이다.</p>
<p><code>readonly</code>는 접근 제한자와 섞어서도 사용할 수 있다. 다음과 같은 문법으로 사용한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Rect &#123;</div><div class="line">  <span class="keyword">private</span> readonly width : <span class="built_in">number</span>;</div><div class="line">  <span class="keyword">private</span> readonly height: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params">width, height</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.width  = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">set</span> width(width) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width; <span class="comment">// ERROR: Left-hand side of assignment expression cannot be a constant or a read-only property.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>쉽게 예상할 수 있었겠지만, <code>readonly</code> 프로퍼티에 새 값을 할당하려고 하면 에러를 출력하게 된다.</p>
<h2 id="추상-클래스-Abstract-class"><a href="#추상-클래스-Abstract-class" class="headerlink" title="추상 클래스(Abstract class)"></a>추상 클래스(Abstract class)</h2><p>추상 클래스는 <em>추상 메소드(Abstract method)</em> 를 가질 수 있는 클래스다. 추상 메소드란 구현부가 없는 메소드다. 추상 클래스를 상속하는 클래스에서는 반드시 추상 클래스의 추상 메소드를 구현해야 한다. 또한 추상 클래스로는 객체 인스턴스를 생성할 수 없다. 상속용으로만 기능한다.</p>
<p>인터페이스(Interface)를 알고 계신 분이라면 인터페이스와 뭐가 다른지 궁금할 것이다. 인터페이스는 모든 메소드가 추상 메소드이다. 추상 클래스는 추상 메소드만 포함할 수 있는 것이 아니라, 실제 구현이 있는 메소드도 포함할 수 있다. 인터페이스는 이외에도 많은 기능들과 개념을 포함하고 있으므로, 이에 대해서는 다음 글에서 다루려고 한다.</p>
<p>다음 글 - <a href="/2016/10/17/typescript-interface">TypeScript: 인터페이스(Interface)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/10/02/typescript-basic-type&quot;&gt;TypeScript: Basic Type&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;클래스는 JavaScript 생
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>첫 번째 이직</title>
    <link href="https://hyunseob.github.io/2016/10/15/my-first-changing-company/"/>
    <id>https://hyunseob.github.io/2016/10/15/my-first-changing-company/</id>
    <published>2016-10-14T15:51:59.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>이직을 하게 됐다. 가만히 앉아있는데 무슨 오퍼가 와서 이직하게 된 건 아니고(일부 맞는 말이기는 한데..), 내가 원해서 새 직장을 찾게 되었다. 물론 이직을 하게 된 동기도 있지만.. 그건 개인적인 추억으로 간직해야겠다.</p>
<p>많은 곳에 이력서를 냈다. 내가 본격적으로 JavaScript를 메인 언어로 하는 웹 개발자가 된 것이 약 1년 3개월 정도 되었고, 전 직장에서 머리도 꽤 커져서 이직 준비를 시작할 때는 나름 자신감도 있었다. 하지만 실제로 도전해보니 수 많은 곳에서 면접도 보지 못하고 광탈당했다. 물론 어떻게 보면 내가 욕심이 너무 많은 것은 아닌가 싶기도 했지만.. 뭐. 취준하시는 분들은 공감하시겠지만 그러다보면 자신감은 땅에 떨어지고, 내가 지금까지 걸어온 길이 틀린 거 아닌가 하는 생각도 든다.</p>
<p><img src="/images/mang.jpg" alt="망했어요"></p>
<p>그럼에도, 날 좋게 봐준 회사 역시 있었다. 등록했던 이력서를 통해 연락이 오기도하고, 링크드인을 통해 헤드헌터의 연락을 받기도 했다. 내가 직접 서류를 낸 곳에서도 꽤 면접제의가 와서 면접도 봤다. 솔직히 어지간히 마음에 들지 않는 수준이 아니고서야, 대부분의 면접제의는 거절하지 않았다. 왜냐하면 면접 결과가 어찌되든 그 과정에서 얻는 것이 많다고 느꼈기 때문이다. 기술적이건 비기술적이건간에 면접을 하나 거칠 때마다 배우는 게 있었고, 또 스스로의 부족함을 많이 느끼게 되었다. 그게 자기 발전을 위한 촉매가 되었음은 두 말할 것 없다.</p>
<p>그렇게 정신없이 면접을 거치는 동안, 최종 오퍼도 하나, 둘.. 여러 곳에서 받게 되었다. 어떤 회사는 여러 번의 면접을 거치면서 내부 문화나 근무 조건 등이 마음에 들지 않아서 채용을 거절하기도 하고, 또 나름대로 최대한 괜찮은 선택을 하기 위해서 결정을 유보하다가 채용을 거절하기도 했다. 꼭 어딘가 다른 곳에 갈 수 있다는 보장이 없는 상태에서 오퍼를 거절하게 되니 사실 불안하기도 했다.</p>
<p>채용을 여러 군데 거절하고, 어떤 곳은 결과를 기다리고 있는 상태로 스튜디오씨드(Studio XID)라는 팀에 면접을 보러가게 되었다. 원티드라는 채용 플랫폼을 통해 매칭이 되었는데, 먼저 면접 제의를 주셔서 다소 들뜬 마음으로 보러가게 되었다. 채용 절차는 매우 심플하게도 면접 1회가 끝이었다. 물론 무척이나 긴 면접이었다. 면접을 보면서 사내 분위기도 좋고, 팀파워도 강하며, 개발 고수가 많아서 내가 성장할 수 있는, 좋은 팀이라는 느낌을 받게 되어서 만약에 여기서 오퍼가 온다면 합류하고 싶다는 생각을 가지게 되었다. 면접 마지막에 장난스럽게 한 시간 뒤에 연락 주겠다고 하시길래 당황했는데, 농담이라고 하셨지만 실제로 면접 후 한 시간 뒤에 연락을 주셔서 정말 놀랐다(…) 나도 면접을 보면서 좋은 팀이라는 확신을 갖게 된 상태였고, 무엇보다도 허접한 날 많이 배려해주셨기 때문에 큰 고민없이 합류를 결정했다.</p>
<p><img src="/images/protopie.png" alt="ProtoPie: Explain your designs without coding"></p>
<p>스튜디오씨드는 <a href="https://protopie.io/" target="_blank" rel="external">ProtoPie</a>라는 디자이너용 마이크로인터랙션 프로토타이핑 소프트웨어를 만드는 팀이다. 규모는 크지 않지만 제품에 대한 시장반응(ProtoPie의 주 타겟은 중국시장이다.)도 좋은 것 같고, 이제 겨우 입사한지 일주일 정도 되었지만.. 내 생각엔 앞으로 잘 될 것 같다. 사내 분위기도 좋고, 팀원 분들도 능력이 출중하시다. 물론 내가 잘하는 게 가장 중요하겠지만.. 원티드에 올라왔던 <a href="https://www.wanted.co.kr/wd/1494" target="_blank" rel="external">채용공고</a>에는 분명 아재개그(…)에 능하거나 견딜 수 있는 멘탈을 우대한다고 되어있는데 멘탈이 남아날지 모르겠다. 아빠의 아재개그 공격에 멘탈이 수없이 박살난 전력이 있는 나로서는 약간의 걱정도 있다.</p>
<p>나름대로 이번에 이직을 하면서 느낀 바가 있는데, 생각보다는 핏이 중요한 거 같다. 물론 실력도 중요하긴 한데, 결국은 핏이 맞아야 되는 거 같다. 나도 가려는 회사와 핏이 맞지 않으면 가고 싶지 않으니까. 핏이 너무 포괄적인 단어라 구체적으로 설명해보자면, ‘앞으로 함께하면서 불필요한 마찰이 생기지 않을 가능성’ 정도로 정의해볼 수 있지 않을까 한다. 사실, 나도 핏이 맞지 않을 것 같아서 제안을 거절하게 된 회사가 있고, 반대로 채용 측에서 내가 핏이 안 맞을까봐 탈락시킨 경우도 있을 것이다. 물론 실력이 압도적이라면 그것도 커버할 수 있겠지만.</p>
<p>그래서 앞으로 개발자로서 많이 성장하고 싶고, ProtoPie를 만들면서 많이 성장할 수 있을 거라고 생각한다. 앞으로의 나날들이 기대된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이직을 하게 됐다. 가만히 앉아있는데 무슨 오퍼가 와서 이직하게 된 건 아니고(일부 맞는 말이기는 한데..), 내가 원해서 새 직장을 찾게 되었다. 물론 이직을 하게 된 동기도 있지만.. 그건 개인적인 추억으로 간직해야겠다.&lt;/p&gt;
&lt;p&gt;많은 곳
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Log" scheme="https://hyunseob.github.io/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>[번역] 반응형 프로그래밍과 RxJS 이해하기</title>
    <link href="https://hyunseob.github.io/2016/10/09/understanding-reactive-programming-and-rxjs/"/>
    <id>https://hyunseob.github.io/2016/10/09/understanding-reactive-programming-and-rxjs/</id>
    <published>2016-10-09T14:43:48.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/reactivex.png"/><p><strong>요약</strong>: RxJS는 이벤트 스트림과 데이터를 쉽게 만들고 다룰 수 있도록 도우는 라이브러리다. 복잡하지만 가독성이 좋은 비동기적 코드를 더 쉽게 작성할 수 있도록 도운다.</p>
<hr>
<p>큰 규모의 비동기 어플리케이션을 작성하는 것은 쉬운 일이 아니다. 모두 <a href="http://callbackhell.com/" target="_blank" rel="external">콜백 헬</a> 이슈를 한 번 쯤은 겪어보았을 것이다. 이런 걱정이 점점 커지면서, 사람들은 스스로 비동기적 JavaScript 세계를 개선했다. 모두 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator</a>나 <a href="https://ponyfoo.com/articles/understanding-javascript-async-await" target="_blank" rel="external">async/await</a>에 대해서 들어보았을 것이다. 또 다른 솔루션이 있다. 바로 <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">RxJS</a>다.</p>
<p>RxJS의 GitHub README에는, RxJS는 “Observable 시퀀스와 표현력있는 쿼리 연산자를 사용하는 비동기적, 이벤트 기반의 프로그램을 구성하기 위한 라이브러리의 집합”이라고 정의되어있다. 이것은 이벤트나 데이터로부터 스트림을 만들 수 있다는 것을 뜻한다. 이 데이터를 가지고 병합(Merge)하거나, 으깨(Mash)거나, 쪼개(Split)는 등의 작업을 할 수 있다. 원하는 데이터가 있으면, 데이터를 순회하면서 무언가를 할 수 있다.</p>
<p>“Observable”이나 “스트림”의 개념은 처음에 이해하기가 어려울 수도 있다. 나는 그것들을 한 번에 한 가지만 사용하는 단일 이벤트 혹은 데이터라고 생각하기 보다는, 어떤 기간동안 다루게 되는 이벤트나 데이터의 컬렉션이라고 생각한다.</p>
<p>RxJS가 어떻게 동작하는지 보기 위해서, 간단한 날씨 어플리케이션을 작성하게 될 것이다. 우편번호를 입력하기 위한 텍스트 input이 있을 것이고, 버튼을 클릭해서 Submit하면 우편번호 위치의 현재 온도 데이터를 얻기 위한 요청이 전송될 것이다. 온도를 얻고나면, 우편번호와 온도를 함께 페이지에 표시할 것이다. 또한 페이지에 많은 온도를 넣어 계속 Watch 하도록 만들 것이다. 그리고 지정한 시간 후에 온도를 새로고침하는 타이머를 만들게 될 것이다. 이제 시작해보자!</p>
<h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><p>첫 번째로 해야할 일은 RxJS 라이브러리를 로드하고 사용할 수 있는 기본적인 HTML 페이지를 만드는 것이다. 또한 약간의 CSS도 포함할 것이다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Weather Monitoring in RxJS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">  #form &#123;</div><div class="line">    margin-bottom: 20px;</div><div class="line">  &#125;</div><div class="line">  .location &#123;</div><div class="line">    float: left;</div><div class="line">    padding: 10px;</div><div class="line">    margin-right: 20px;</div><div class="line">    margin-bottom: 20px;</div><div class="line">    border: 1px solid #ddd;</div><div class="line">    border-radius: 5px;</div><div class="line">  &#125;</div><div class="line">  .location p &#123;</div><div class="line">    margin-top: 10px;</div><div class="line">    margin-bottom: 10px;</div><div class="line">    text-align: center;</div><div class="line">  &#125;</div><div class="line">  .zip &#123; font-size: 2em; &#125;</div><div class="line">  .temp &#123; font-size: 4em; &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"form"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Zip Code:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"zipcode-input"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"add-location"</span>&gt;</span>Add Location<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="comment">// our code will go here</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'RxJS included?'</span>, !!Rx);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>이 파일을 선호하는 브라우저에서 열고, 개발자 콘솔창을 열어보자. <code>RxJS included? true</code> 라는 문장이 나타났는가? 그렇다면 이제 반응형 JavaScript를 작성할 준비가 끝난 것이다! 우편번호를 넣는 <code>&lt;input&gt;</code>과 <code>&lt;button&gt;</code>을 포함하는 간단한 “form”이 있다는 것을 확인하라. 첫 번째 JavaScript 코드는 이 element들의 이벤트로부터 스트림을 만드는 게 될 것이다. 또한 나중에 element들을 추가할 수 있도록 <code>app-container</code>의 참조도 얻을 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Grab HTML elements</span></div><div class="line"><span class="keyword">const</span> appContainer = <span class="built_in">document</span>.getElementById(<span class="string">'app-container'</span>);</div><div class="line"><span class="keyword">const</span> zipcodeInput = <span class="built_in">document</span>.getElementById(<span class="string">'zipcode-input'</span>);</div><div class="line"><span class="keyword">const</span> addLocationBtn = <span class="built_in">document</span>.getElementById(<span class="string">'add-location'</span>);</div></pre></td></tr></table></figure>
<p>평범한 JavaScript 코드다. 별로 특별한 것은 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Get stream of button clicks</span></div><div class="line"><span class="keyword">const</span> btnClickStream =</div><div class="line">  Rx.Observable</div><div class="line">    .fromEvent(addLocationBtn, <span class="string">'click'</span>)</div><div class="line">    .map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>)</div><div class="line">    .forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'btnClickStream val'</span>, val));</div></pre></td></tr></table></figure>
<p>드디어 첫 번째로 RxJS 코드를 작성한다! <code>Rx.Observable</code> 객체의 <code>fromEvent</code> 메소드를 사용하여 <code>addLocationBtn</code>으로부터 발생하는 클릭 이벤트로부터 스트림을 만들었다. 이것은 언제든 버튼이 클릭될 떄마다, 이벤트 객체가 <code>btnClickStream</code>으로 전송된다는 것을 의미한다. 반환된 스트림의 각 값을 <code>true</code>로 매핑하기 위해서 <code>map</code> 메소드를 사용했다. 나는 내 머릿속에 있는 로직을 단순화하는 것을 좋아한다. 이벤트가 일어났는지만 확인하면 되기 때문에 값을 간단한 boolean 값으로 매핑했다. 이것은 그냥 내가 좋아하는 방식이다. 만약 당신의 취향과 맞지 않는다면 지워져도 상관없는 코드다. 마지막으로, 이벤트가 동작하는 지 확인하기 위해서 스트림의 구독자(subscriber)를 추가하는 <code>forEach</code>를 사용한다. 이것이 간단하게 값을 로깅(logging)하는 코드다.</p>
<p><img src="/images/understanding-rx/btn_click_stream.png" alt="버튼 클릭 스트림"></p>
<p>페이지를 새로고침하고, 버튼을 몇 번 클릭해보면 개발자 콘솔에 출력 결과가 보일 것이다. 정상적으로 동작한다! 이제 버튼 스트림에서 <code>forEach</code>를 제거하자. 필요하지 않은 코드다. 이제 우편번호를 얻을 차례다. 우편번호 input에 입력된 문자열의 길이가 5일 때만 이벤트를 수신하고 싶다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Get stream of zip codes</span></div><div class="line"><span class="keyword">const</span> zipInputStream =</div><div class="line">  Rx.Observable</div><div class="line">    .fromEvent(zipcodeInput, <span class="string">'input'</span>)</div><div class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">    .filter(<span class="function"><span class="params">zip</span> =&gt;</span> zip.length === <span class="number">5</span>)</div><div class="line">    .forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'zipInputStream val'</span>, val));</div></pre></td></tr></table></figure>
<p>input 요소로부터 발생한 이벤트로 스트림을 만들었다. input 이벤트로부터 값을 추출하기 위해서 <code>map</code>을 사용한다. 그리고 문자열의 길이가 5가 아닌 값들을 제거하기 위해서 <code>filter</code>를 사용한다. <code>filter</code>는 지정된 조건식이 <code>true</code>를 반환하는 경우 해당 값을 반환되는 스트림에 포함시킨다. 마지막으로, 다시 각 값을 순회하면서 콘솔에 로그를 남긴다.</p>
<p><img src="/images/understanding-rx/zip_input_stream.png" alt="우편번호 입력 스트림"></p>
<p>페이지를 새로고침하고 뭔가를 입력해보면, 입력된 문자열의 길이가 5일 때만 값을 확인할 수 있다는 사실을 알 수 있다. 잘하고 있다. <code>forEach</code>를 제거하자. 이제 유저가 버튼을 클릭했을 때만 input에 있는 값을 전달하도록 만들 것이다. 이를 위한 새로운 스트림을 만들어보자!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Get zipcode after button clicked</span></div><div class="line"><span class="keyword">const</span> zipcodeStream =</div><div class="line">  btnClickStream</div><div class="line">    .withLatestFrom(zipInputStream, (click, zip) =&gt; zip)</div><div class="line">    .distinct()</div><div class="line">    .forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'zipcodeStream val'</span>, val));</div></pre></td></tr></table></figure>
<p><code>btnClickStream</code>의 <code>withLatestFrom</code>을 호출하여 <code>zipInputStream</code>을 넘겼다. 이것은 <code>btnClickStream</code>의 값이 보일때마다 <code>zipInputStream</code>의 가장 최근 값을 얻고 <code>map</code>처럼 동작하는 함수인 “result selector”로 전달하는 것을 의미한다. 이 함수에서 반환된 값은 <code>withLatestFrom</code>으로부터 반환된 스트림에 전달된다. 다음으로, 새로운 값만을 얻기 위해 <code>distinct</code> 메소드를 사용한다. 중복된 값이 존재한다면, 그 값은 <code>distinct</code>로 인해 반환된 스트림에는 전달되지 않는다. 그리고 당연하지만, 제대로 동작하는지 확인하기 위해서 로그를 <code>forEach</code>를 사용해 출력하였다.</p>
<p><img src="/images/understanding-rx/zip_stream.png" alt="우편번호 스트림"></p>
<p>페이지를 새로고침하고, 우편번호를 입력한 후에 버튼을 클릭해보자. 개발자 콘솔을 보면, 버튼이 클릭될 때 우편번호가 스트림으로 submit 되는 것을 확인할 수 있다. 이제, 아까 했던 것처럼, <code>forEach</code> 문을 제거한다. 우편번호가 추가되거나 타이머의 시간이 지날 때마다 호출할 재사용성 높은 날씨 API가 필요하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Create reusable temperature fetching stream</span></div><div class="line"><span class="keyword">const</span> getTemperature = <span class="function"><span class="params">zip</span> =&gt;</span></div><div class="line">  fetch(<span class="string">`http://api.openweathermap.org/data/2.5/weather?q=<span class="subst">$&#123;zip&#125;</span>,us&amp;units=imperial&amp;appid=APPID`</span>)</div><div class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json());</div><div class="line"></div><div class="line"><span class="keyword">const</span> zipTemperatureStreamFactory = <span class="function"><span class="params">zip</span> =&gt;</span></div><div class="line">  Rx.Observable</div><div class="line">    .fromPromise(getTemperature(zip))</div><div class="line">    .map(<span class="function">(<span class="params">&#123; main: &#123; temp &#125; &#125;</span>) =&gt;</span> (&#123; temp, zip &#125;));</div></pre></td></tr></table></figure>
<p>두 개의 함수를 제작하였다. 첫 번째 함수, <code>getTemperature</code>는 우편번호를 받아 날씨 API에서 온도를 받아오는 요청을 만든다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external"><code>fetch</code></a>가 Promise를 반환하므로, Promise에 있는 메소드인 <code>then</code>을 호출할 수 있다. 이 Promise는 응답을 받아 더욱 쉽게 활용할 수 있는 JSON 포맷을 리턴한다. 이것은 이 함수가 Promise를 반환한다는 것을 의미한다. 이건 중요하다. 또한, <code>APPID</code>를 <a href="https://home.openweathermap.org/api_keys" target="_blank" rel="external">OpenWeatherMap 관리자 페이지에서 받을 수 있는 무료 API 키</a>로 변경하는 걸 잊지마시기 바란다.</p>
<p>두 번째 함수는 우편번호를 받는다. <code>Rx.Observable</code>의 <code>fromPromise</code> 메소드를 사용하여 <code>getTemperature</code> 함수에서 반환된 Promise로 스트림을 생성한다. 이것은 스트림을 반환하기 때문에, <code>Rx.Observable</code> 인스턴스가 가지는 메소드를 모두 사용할 수 있다. 현재 우편번호와 온도에만 관심이 있기 때문에, 해당 정보만 보유하는 객체를 반환하도록 하자. Promise 스트림에 <code>map</code>을 사용하여 입력을 destructuring하여 온도를 출력하고, 원하는 데이터를 포함하는 객체를 반환한다. ES2015의 새로운 destructuring 문법에 대한 더 많은 정보는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">MDN을 참고하시기 바란다</a>.</p>
<p>이제 날씨 API로부터 데이터를 얻는 함수가 완성되었다. 마지막으로 페이지에 element를 추가하도록 하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Get new zip at each button click, get its</span></div><div class="line"><span class="comment">// temperature, and paint it to the screen</span></div><div class="line">zipcodeStream</div><div class="line">  .flatMap(zipTemperatureStreamFactory)</div><div class="line">  .forEach(<span class="function">(<span class="params">&#123; zip, temp &#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> locationEle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    locationEle.id = <span class="string">`zip-<span class="subst">$&#123;zip&#125;</span>`</span>;</div><div class="line">    locationEle.classList.add(<span class="string">'location'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> zipEle = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</div><div class="line">    zipEle.classList.add(<span class="string">'zip'</span>);</div><div class="line">    zipEle.innerText = zip;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> tempEle = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</div><div class="line">    tempEle.classList.add(<span class="string">'temp'</span>);</div><div class="line">    tempEle.innerHTML = <span class="string">`<span class="subst">$&#123;temp&#125;</span>&amp;deg;F`</span>;</div><div class="line"></div><div class="line">    locationEle.appendChild(zipEle);</div><div class="line">    locationEle.appendChild(tempEle);</div><div class="line">    appContainer.appendChild(locationEle);</div><div class="line"></div><div class="line">    zipcodeInput.value = <span class="string">''</span>;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>이제 우편번호 스트림의 <code>flatMap</code> 메소드를 호출한다. <code>flatMap</code>은 스트림으로 만들어진 스트림을 인자로 받아 각 스트림으로부터 값을 얻고 스트림으로 반환하여 사용가능하게 한다는 점만 제외한다면 일반 <code>map</code>처럼 동작한다. 즉, 날씨 API로의 요청으로부터 만들어진 스트림들을 납작하게(flatten) 만들고 스트림으로부터 얻어지는 값인 우편번호와 온도를 가지는 객체를 제공하는 메소드이다.</p>
<p>마지막 파트에서는 <code>forEach</code>를 사용하여 각 데이터를 얻고, 페이지에 추가한다. 콜백 함수 내에 있는 모든 코드는 순수한 JavaScript로 이루어져 있다. element를 구성하고 페이지에 추가한다. 그리고 <code>zipcodeInput</code>의 값을 비워준다.</p>
<p><img src="/images/understanding-rx/initial_add_to_page.png" alt="페이지에 요소가 추가된 모습"></p>
<p>페이지를 새로고침하고 우편번호를 몇 개 입력해보자. 페이지에 우편번호와 온도가 포함된 새로운 element가 추가된 것을 볼 수 있을 것이다.</p>
<p>이제 페이지에 온도가 표시되기 시작했으니, 이제 그것들을 업데이트 할 수 있는지 확인해보자. 지정한 시간마다 값을 출력하는 스트림은 만들 수 있다. 그러나, 입력한 모든 우편번호를 얻을 수 있는지 확인해 봐야한다. 이를 위해, <code>ReplaySubject</code>를 사용할 수 있다. <code>ReplaySubject</code>는 스트림을 구독하고 스트림으로부터 받은 모든 값을 기억한다. 그리고 그것을 원할 때마다 반복할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Create stream that can replay all zips at will</span></div><div class="line"><span class="keyword">const</span> replayZipsStream = <span class="keyword">new</span> Rx.ReplaySubject();</div><div class="line">zipcodeStream.subscribe(replayZipsStream);</div></pre></td></tr></table></figure>
<p>새로운 <code>ReplaySubject</code>를 만들고 <code>zipcodeStream</code>을 구독했다. 이것은 <code>ReplaySubject</code>가 입력하는 모든 우편번호를 기억할 것이라는 것이다. 한 번 사용해보자!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Create a timer to refresh the data</span></div><div class="line"><span class="comment">// and update the page</span></div><div class="line">Rx.Observable</div><div class="line">  .interval(<span class="number">20000</span>)</div><div class="line">  .flatMapLatest(<span class="function"><span class="params">()</span> =&gt;</span> replayZipsStream)</div><div class="line">  .flatMap(zipTemperatureStreamFactory)</div><div class="line">  .forEach(<span class="function">(<span class="params">&#123; zip, temp &#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Updating!'</span>, zip, temp);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> locationEle = <span class="built_in">document</span>.getElementById(<span class="string">`zip-<span class="subst">$&#123;zip&#125;</span>`</span>);</div><div class="line">    <span class="keyword">const</span> tempEle = locationEle.querySelector(<span class="string">'.temp'</span>);</div><div class="line"></div><div class="line">    tempEle.innerHTML = <span class="string">`<span class="subst">$&#123;temp&#125;</span>&amp;deg;F`</span>;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>첫 번째로 해야할 일은 지정한 시간마다 값을 출력하는 스트림을 만드는 것이다. 그 값은 신경쓸 부분이 아니다. 단지 그 값이 출력되는 시간이 필요한 것이다. 그리고 <code>ReplaySubject</code>인 콜백 함수로부터 얻을 수 있는 스트림을 납작하게 하기 위해서 새로운 메소드인 <code>flatMapLatest</code>를 사용한다. <code>flatMap</code> 대신에 <code>flatMapLatest</code>를 사용하는 이유는 <code>replayZipsStream</code>이 단 하나의 구독자만 가지는 것을 보장하고 싶기 때문이다. 그냥 <code>flatMap</code>을 사용했다면 같은 <code>ReplaySubject</code>에 여러 개의 구독자를 추가했을 것이고, 그렇게 되면 날씨 API로 쓸데 없는 여러 개의 요청을 날리게 될 것이다. 어쨌든 페이지에 추가했던 우편번호 스트림을 얻었을 것이다. 이제 이것을 같은 방식으로 사용할 수 있다. <code>flatMap</code>을 사용하여 날씨 API로 보내는 요청을 만드는 팩토리 함수에 통과시키도록 하자. 마지막으로, 그것들을 모두 순회하면서 각각 응답을 받아 페이지에 있는 데이터를 업데이트 하면 된다.</p>
<p><img src="/images/understanding-rx/timer_stream.png" alt="타이머 스트림"></p>
<p>마지막으로 페이지를 새로고침 한 뒤에, 몇 개의 우편번호를 추가해보자. 정상적으로 페이지에 추가된 것을 볼 수 있을 것이다. 20초를 기다리면 개발자 콘솔에 값이 업데이트 되었다는 메시지를 볼 수 있을 것이다. 20초 동안 온도 변화가 없다면, 페이지에는 아무 변화도 없을 수 있다. 더 자주 혹은 뜸하게 시간 간격을 주고 싶다면, 필요에 알맞게 <code>Rx.Observable.interval</code>에 넘기는 값을 변경하면 된다.</p>
<h2 id="Auth0-Lock과-함께-쓰기1"><a href="#Auth0-Lock과-함께-쓰기1" class="headerlink" title="Auth0 Lock과 함께 쓰기1"></a>Auth0 Lock과 함께 쓰기<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><p>이제 당신은 스트림을 제대로 쓸 수 있게 되었다. 그런데 날씨 어플리케이션의 인증 솔루션으로 <a href="https://auth0.com/lock" target="_blank" rel="external">Auth0 Lock</a>을 쓰고 싶을 수 있다. 어떻게 구현하면 될까? 뭐, 매우 간단하다. 대부분의 일은 라이브러리에 의해 처리된다. 그냥 버튼을 클릭했을 때 Lock 모달이 나오는 것만 확실하게 하면 된다. 한 번 해보자!</p>
<p>먼저, 라이브러리를 포함한 다음, Lock을 초기화 하고, 모달을 띄울 로그인 버튼을 추가하자.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"login"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.auth0.com/js/lock/10.x.y/lock.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">// Initiating our Auth0Lock</span></div><div class="line">    <span class="keyword">var</span> lock = <span class="keyword">new</span> Auth0Lock(</div><div class="line">      <span class="string">'YOUR_CLIENT_ID'</span>,</div><div class="line">      <span class="string">'YOUR_NAMESPACE'</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// Listening for the authenticated event</span></div><div class="line">    lock.on(<span class="string">"authenticated"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">authResult</span>) </span>&#123;</div><div class="line">      <span class="comment">// Use the token in authResult to getProfile() and save it to localStorage</span></div><div class="line">      lock.getProfile(authResult.idToken, <span class="function"><span class="keyword">function</span>(<span class="params">error, profile</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">          <span class="comment">// Handle error</span></div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        localStorage.setItem(<span class="string">'idToken'</span>, authResult.idToken);</div><div class="line">        localStorage.setItem(<span class="string">'profile'</span>, <span class="built_in">JSON</span>.stringify(profile));</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>마지막으로 남은 일은 버튼 이벤트를 스트림으로 전환하고, 그 스트림에서 데이터를 받을 때마다 모달을 여는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Rx.Observable</div><div class="line">  .fromEvent(<span class="built_in">document</span>.getElementById(<span class="string">'login'</span>), <span class="string">'click'</span>)</div><div class="line">  .forEach(<span class="function"><span class="params">()</span> =&gt;</span> lock.open());</div></pre></td></tr></table></figure>
<p>이렇게 완료됐다.</p>
<h2 id="Gotta-Stream-Them-All"><a href="#Gotta-Stream-Them-All" class="headerlink" title="Gotta Stream Them All"></a>Gotta Stream Them All</h2><p>Observable 혹은 스트림이라는 용어는 처음엔 약간 생소하게 느껴질 수 있다. 내가 접근했던 방법은 싱글 이벤트라는 생각 대신 일정 시간 동안의 이벤트 컬렉션이라고 생각하는 것이었다. 이렇게 하면 DOM으로부터 발생하는 모든 이벤트를 스트림으로 생각하는 것은 식은 죽 먹기일 것이다. RxJS는 쉽게 이벤트로부터 스트림을 만들고 상호작용할 수 있도록 돕는다. RxJS는 어플리케이션 로직을 유지하고, 다른 프레임워크 혹은 라이브러리를 사용할 떄보다 코드를 쉽게 만들어주는 강력한 방법이다. 늘 그렇듯이 코멘트 달아주시고 얼마나 RxJS를 좋아하는지 알려주시기 바란다.</p>
<p><a href="https://auth0.com/blog/understanding-reactive-programming-and-rxjs/" target="_blank" rel="external">[ 원문 보기 ]</a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><strong>역자 주</strong>: 이 쪽은 광고문단에 가까우니 참고.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/reactivex.png&quot;/&gt;&lt;p&gt;&lt;strong&gt;요약&lt;/strong&gt;: RxJS는 이벤트 스트림과 데이터를 쉽게 만들고 다룰 수 있도록 도우는 라이브러리다. 복잡하지만 가독성이 좋은 비동기적 코드를 더 쉽게 작성할 수 
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="RxJS" scheme="https://hyunseob.github.io/categories/JavaScript/RxJS/"/>
    
    
      <category term="Translate" scheme="https://hyunseob.github.io/tags/Translate/"/>
    
      <category term="Tutorial" scheme="https://hyunseob.github.io/tags/Tutorial/"/>
    
      <category term="ReactiveX" scheme="https://hyunseob.github.io/tags/ReactiveX/"/>
    
      <category term="RxJS" scheme="https://hyunseob.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: Basic Type</title>
    <link href="https://hyunseob.github.io/2016/10/02/typescript-basic-type/"/>
    <id>https://hyunseob.github.io/2016/10/02/typescript-basic-type/</id>
    <published>2016-10-02T12:29:57.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/09/25/typescript-introduction">TypeScript: 소개</a></p>
<p>이번 글에서는 TypeScript에서 제공하는 Basic Type들을 알아볼 것이다. 개인적으로 공부하고 정리한 글이니 퀄리티가 많이 낮을 수도 있다.</p>
<h2 id="Type-annotation"><a href="#Type-annotation" class="headerlink" title="Type annotation"></a>Type annotation</h2><p>먼저 TypeScript의 타입들을 알아보기 전에 Type annotation을 알아본다. 일반 변수 선언의 경우 Type annotation은 다음과 같이 쓴다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> name: <span class="built_in">string</span> = <span class="string">'HyunSeob'</span>;</div></pre></td></tr></table></figure>
<p>간단하다. 변수의 식별자 뒤에 콜론(:)을 붙이고 그 뒤에 타입을 정의하면 된다.</p>
<p>함수를 정의하는 경우 다음과 같이 쓴다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params">param: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> param;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>마찬가지로 매개변수 옆에 콜론을 찍고 타입을 입력하기만 하면(공백무시) JavaScript와 다른 점이 없다. 함수의 경우는 매개변수를 넘기는 괄호 후에 콜론 후 타입을 적으면 된다.</p>
<h2 id="JavaScript-지원-타입"><a href="#JavaScript-지원-타입" class="headerlink" title="JavaScript 지원 타입"></a>JavaScript 지원 타입</h2><p>TypeScript가 언어차원에서 기본적으로 지원하는 Type은 두 종류로 분류할 수 있다. Basic Type과 Advanced Type. 이번 글에서는 이 중 Basic Type만 다룬다. Basic Type은 다시 두 가지로(순전히 나만의 분류) 나눌 수 있다. JavaScript에 이미 존재하는 것과 그렇지 않은 것. JavaScript에 존재하는 타입들의 목록은 다음과 같다.</p>
<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Array</li>
<li>Null / Undefined</li>
</ul>
<p>위에 나열한 타입들은 기본적인 JavaScript 지식만 가지고 있더라도 모두 아는 타입일테니 누차 설명은 하지 않겠다. 다만 몇 가지 주의할 점에 대해서만 얘기하고 넘어가도록 하겠다.</p>
<h3 id="boolean-Boolean"><a href="#boolean-Boolean" class="headerlink" title="boolean? Boolean?"></a>boolean? Boolean?</h3><p>JavaScript에서는 위와 같은 JavaScript primitive type들에 대해 래핑한 객체를 제공한다. TypeScript도 이를 지원하므로 다음과 같이 코드를 쓸 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> isLiar: <span class="built_in">boolean</span> = <span class="literal">true</span>; <span class="comment">// OK</span></div><div class="line"><span class="keyword">const</span> isTruth: <span class="built_in">Boolean</span> = <span class="literal">false</span>; <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>가급적이면 <code>boolean</code>을 사용하는 것이 권장된다. <code>new Boolean()</code>으로 생성한 값을 <code>boolean</code> 타입에 할당할 수는 있으나 그 반대는 안되기 때문이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> isLiar: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// OK</span></div><div class="line"><span class="keyword">const</span> isTruth: <span class="built_in">Boolean</span> = <span class="literal">false</span>; <span class="comment">// Error: Type 'Boolean' is not assignable to type 'boolean'.</span></div><div class="line"><span class="comment">// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.</span></div></pre></td></tr></table></figure>
<p>물론, 리터럴 문법 대신 저렇게 래핑 객체를 이용하여 생성자를 호출하는 것이 JavaScript에서도 권장하지 않는 방법이다.</p>
<p>위의 사항은 <code>Number</code> &amp; <code>number</code>, <code>String</code> &amp; <code>string</code> 등에서도 해당되는 부분이므로 타입 명시할 때 헷갈리지 말도록 하자.</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Array는 두 가지 방법으로 선언이 가능하다. 먼저 Array 리터럴을 이용한 방식.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> animals: <span class="built_in">string</span>[] = [ <span class="string">'Cow'</span>, <span class="string">'Dog'</span>, <span class="string">'Cat'</span> ];</div></pre></td></tr></table></figure>
<p>그 다음은 제네릭이라는 것을 사용하는 방식이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> animals: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [ <span class="string">'Cow'</span>, <span class="string">'Dog'</span>, <span class="string">'Cat'</span> ];</div></pre></td></tr></table></figure>
<p><code>Array</code>뒤에 뾰족한 괄호와 같이 사용되는 것이 <em>제네릭(Generic)</em> 문법이다. 제네릭은 Java에서는 흔히 알려진 개념이지만 동적 타이핑 언어인 JavaScript에서는 접할 일이 없는 개념이므로 약간 생소할 수도 있겠다. TypeScript의 제네릭에 대해서는 나중에 따로 다뤄보기로 하고 일단은 저런 것이 있다라고만 생각하고 넘어가면 되겠다. 나의 경우는 Java보다는 C++에 익숙하기 때문에 C++의 템플릿 문법과 닮았다는 생각을 했다.</p>
<h3 id="Null-amp-Undefined"><a href="#Null-amp-Undefined" class="headerlink" title="Null &amp; Undefined"></a>Null &amp; Undefined</h3><p>JavaScript에서도 그랬듯 <code>null</code>이나 <code>undefined</code>는 모든 타입의 변수로 할당할 수 있다. 하지만 TypeScript의 <code>null</code> 타입과 <code>undefined</code> 타입은 다른 변수를 할당해버리면 에러가 난다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> onlyNull: <span class="literal">null</span> = <span class="literal">null</span>;</div><div class="line">onlyNull = <span class="literal">undefined</span>; <span class="comment">// OK</span></div><div class="line">onlyNull = <span class="literal">false</span>; <span class="comment">// error: Type 'boolean' is not assignable to type 'null'.</span></div></pre></td></tr></table></figure>
<p>솔직히 왜 있는 타입인지는 잘 모르겠다. 실제로 JavaScript를 쓰면서 항상 <code>null</code> 이거나 <code>undefined</code>인 변수를 쓸 일이 없었기 때문.</p>
<h2 id="TypeScript-추가-타입"><a href="#TypeScript-추가-타입" class="headerlink" title="TypeScript 추가 타입"></a>TypeScript 추가 타입</h2><p>TypeScript에서는 JavaScript에서 지원하지 않는 타입들을 만들어 지원하고 있다. 목록은 다음과 같다.</p>
<ul>
<li>Tuple</li>
<li>Any</li>
<li>Void</li>
<li>Never</li>
<li>Enum</li>
</ul>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>Python을 해봤다면 Python의 Tuple이 쉽게 연상될 것이다. 그러나 TypeScript의 Tuple은 Python의 그것과는 많이 다르다. 먼저 Python의 Tuple은 요소의 숫자가 고정되어있고 immutable(수정불가능한) 리스트인데 TypeScript에서는 자유롭게 추가, 삭제, 수정이 가능하다. TypeScript의 Tuple은 다음과 같이 정의한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> tuple: [ <span class="built_in">boolean</span>, <span class="built_in">number</span> ] = [ <span class="literal">true</span>, <span class="number">0</span> ];</div><div class="line">tuple.concat([ <span class="literal">false</span>, <span class="number">1</span> ]);</div><div class="line">tuple.push(<span class="string">'string'</span>); <span class="comment">// Error: Argument of type 'string' is not assignable to parameter of type 'number | boolean'.</span></div></pre></td></tr></table></figure>
<p>Tuple의 기본적인 성격은 Array랑 동일하다. 차이점은 요소로 가질 수 있는 타입이 여러가지로 나뉠 수 있다는 것이다. 위의 Tuple은 <code>boolean</code>, <code>number</code>만 받을 수 있는 Tuple이다. 그러나 3번째 줄에서 <code>string</code> 타입을 추가하려고 하면서 에러가 생겼다.</p>
<p>에러메시지를 보면 타입이 <code>number</code>나 <code>boolean</code>이 아니기에 할당할 수 없다고 한다. 때문에 순서에 관계없이 선언된 두 종류의 타입 중 하나면 요소가 될 수 있는 건가? 라는 생각을 할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> tuple: [ <span class="built_in">boolean</span>, <span class="built_in">number</span> ] = [ <span class="number">0</span>, <span class="literal">true</span> ]; <span class="comment">// Error: Type '[number, boolean]' is not assignable to type '[boolean, number]'.</span></div></pre></td></tr></table></figure>
<p>하지만 위와 같이 순서도 중요하다. 단, 애초에 선언한 index일 때만 중요하다. 그러니까, 위의 경우 0번째 요소는 반드시 <code>boolean</code> 타입이어야하고, 1번째 요소는 반드시 <code>number</code> 타입이어야 하는 것이다. 그 뒤의 2, 3, 4… 번째 요소의 타입은 그냥 <code>boolean || number</code>이면 된다.</p>
<p>또한, 값을 할당할 때는 선언한 만큼 요소를 할당해야한다. 이를테면 다음과 같은 경우 에러가 난다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> tuple: [ <span class="built_in">boolean</span>, <span class="built_in">number</span> ] = [ <span class="literal">true</span> ]; <span class="comment">// Error: Type '[true]' is not assignable to type '[boolean, number]'.</span></div></pre></td></tr></table></figure>
<p>TypeScript Tuple은 요소의 추가, 삭제, 수정이 자유롭지만 실제로 그렇게 쓰는 것 보다는, Python의 Tuple처럼 고정된 크기의 배열로 사용하는 것이 옳은 사용법이라고 할 수 있다.</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>Any는 문자 그대로 어떤 타입이든 통과하는 타입이다. 예를 들면,</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> anyVar: <span class="built_in">any</span> = <span class="literal">true</span>;</div><div class="line">anyVar = <span class="number">1</span>;</div><div class="line">anyVar = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>이런 식으로 어떤 타입의 값을 할당해도 오류가 나지 않는다. 정적 타입 검사가 없으므로 JavaScript와 차이가 없고 TypeScript의 장점이 드러나지 않는 만큼 되도록이면 사용을 지양해야겠지만, JavaScript 기반의 프로그램을 만드는 경우 어쩔 수 없이 사용해야 하는 경우가 종종 있다.</p>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>Void는 함수에서만 특히 활용하는 타입이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">arr</span>): <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(arr.join(<span class="string">', '</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 함수처럼 리턴하는 값이 없는 함수의 경우 리턴 타입으로 <code>void</code>를 명시해줄 수 있다. 그러나 <code>null</code> 혹은 <code>undefined</code> 값을 할당할 수 있는 타입이므로 <code>return null;</code> 또한 가능하다. 변수에도 지정가능한 타입이지만, Null &amp; Undefined 타입과 마찬가지로 <code>null</code>과 <code>undefined</code>밖에 할당할 수 없으므로 별로 쓸모가 없다.</p>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>Never는 좀 이상한 타입이다. 먼저 Never 타입엔 <code>null</code>, <code>undefined</code>를 비롯해 어떤 값도 할당할 수 없다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> neverVar: never = <span class="literal">null</span>; <span class="comment">// Error: Type 'null' is not assignable to type 'never'.</span></div></pre></td></tr></table></figure>
<p>함수에 활용하는 경우 어떤 값도 리턴하지 않는 정도를 넘어서 도달 불가능한 부분이 있어야 타입 체크를 통과한다. 예를 들면, 항상 에러를 호출하는 함수이거나 무한루프가 포함된 함수여야 한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysError</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>실사례에서 어떤 경우에 활용할 수 있는 지는 아직 잘 모르겠다(…)</p>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>Enum은 어떤 변수에 값으로 할당할 수 있는 요소들의 집합이다. 타 언어에서 보던 Enumertaion과 흡사한 개념이다. 다음과 같은 문법을 가진다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Fruit &#123; Apple, Banana, Melon &#125;;</div><div class="line"><span class="keyword">let</span> fruit: Fruit = Fruit.Apple;</div></pre></td></tr></table></figure>
<p>그러나 앞선 타입과 달리 Enum은 정적 타이핑 검사만을 지원하는 개념이 아니고 실질적으로 JavaScript로 컴파일되면서 코드가 생성되는 부분도 있어서 다른 글에서 좀 더 깊게 다룰 생각이다.</p>
<p>다음 글 - <a href="/2016/10/17/typescript-class">TypeScript: 클래스(Class)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/09/25/typescript-introduction&quot;&gt;TypeScript: 소개&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 TypeScript에서 제공
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 소개</title>
    <link href="https://hyunseob.github.io/2016/09/25/typescript-introduction/"/>
    <id>https://hyunseob.github.io/2016/09/25/typescript-introduction/</id>
    <published>2016-09-25T12:23:52.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>JavaScript that scales.<br><cite>TypeScript 캐치프레이즈</cite></p>
</blockquote>
<p><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>는 Microsoft에서 개발하여 2012년에 발표한 JavaScript로 컴파일 되는 언어이다. JavaScript에 정적 타이핑과 ES2015를 기반으로 하는 객체지향적 문법이 추가된 것을 주요 특징으로 한다. 나올 당시에는 Windows 이외의 다른 개발 환경지원이 미비해서 부정적인 의견도 적지 않았던 것으로 알고 있지만, 생태계 지원이 점점 확장되고, 최근에는 Angular 팀에서 이 언어를 메인 언어로 채택하면서 현재로서는 정적 타이핑을 지원하는 다른 JavaScript 전처리기(Flow 등)에 비해서 커뮤니티나 안정성 측면에서 앞서나가는 모양새다.</p>
<p>JavaScript로 컴파일 되는 언어라고 하니 CoffeeScript가 떠오른다. 그러나 TypeScript는 CoffeeScript와는 달리 JavaScript의 Superset이라는 차이점이 있다. 즉, 지금까지 사용했던 익숙한 JavaScript의 문법을 사용하면서도 코딩이 가능하다. 특히, TypeScript는 ES2015 문법도 지원하므로 TypeScript 이외의 별도 Transpiler를 사용하지 않아도 ES2015 기능들을 브라우저에서 사용할 수 있다는 장점도 있다. 게다가 미래의 ECMAScript Feature들도 계속해서 지원할 예정이므로 표준에서 벗어날 걱정도 덜 수 있겠다.</p>
<p><img src="/images/ts-es6-es5.png" alt="TypeScript &gt;= ES6 &gt;= ES5"></p>
<p>TypeScript는 오픈 소스이며, 마이크로소프트는 TypeScript를 계속해서 개선하고 있다. 최근에는 v2.0 버전이 배포되었고 여러가지 기능이나 이슈는 지금도 계속 보완되는 중이다.</p>
<h2 id="Why-use"><a href="#Why-use" class="headerlink" title="Why use?"></a>Why use?</h2><p>TypeScript를 사용하면 정적 타이핑이 가지는 장점을 JavaScript에 적용할 수 있다. 정적 타이핑은 컴파일 타임에 타입 체크를 한다. 당연히 에러는 발생하지 않는 게 가장 좋지만 만약 발생했다면 컴파일타임 에러가 런타임 에러보다 낫다.</p>
<p>문서화 측면에서도 뛰어나다. JavaScript 문서화 도구인 JSDoc이 Type annotation을 지원하는 것과 일맥상통한다. 제대로 된 Type annotation은 그 자체로 문서화다.</p>
<p>물론 정적 타이핑과 동적 타이핑은 무엇이 우위라고 볼 수 없는 것이 사실이다. 이 관계에는 Trade-off가 있다고 볼 수 있으며, 일반적으로 꼽는 정적 타이핑의 단점은 바로 생산성이다. 때문에 TypeScript에서는 생산성보다는 안정성이 중요시되는 대규모 JavaScript 어플리케이션 개발에 적합하다고 한 것이다.</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>TypeScript의 기능들은 크게 보면 정적 타이핑과 ECMAScript 구현으로 나뉠 수 있다.</p>
<ul>
<li>Type annotation &amp; 정적 타입 체크</li>
<li>타입 추론</li>
<li>Interfaces</li>
<li>ES2015 Features<ul>
<li><code>let</code> &amp; <code>const</code></li>
<li>Block scope</li>
<li>Arrow functions</li>
<li>Classes</li>
<li>Promise</li>
<li>Etc…</li>
</ul>
</li>
<li>Namespaces &amp; Modules(CommonJS, ES2015, AMD)</li>
<li>Generic</li>
<li>Mixin</li>
</ul>
<hr>
<p>앞으로 종종 공부 겸해서 블로그에 TypeScript의 여러가지 기능에 대해서 다루는 글을 쓸 예정인데, 웬만하면 ES2015의 기능보다는 TypeScript에만 있는 기능에 대해서 집중적으로 다뤄보려고 한다.</p>
<p>혹시 더 관심있는 분은 <a href="https://github.com/HyunSeob/typescript-TodoMVC" target="_blank" rel="external">typescript-TodoMVC</a>도 참조하시기 바란다. 바로 몇 일 전부터 혼자서 TypeScript 공부 겸 진행한 프로젝트이다. 부족한 퀄리티이긴 하지만 시작하는 분께는 어느 정도 참고가 될 수 있지 않을까? 물론 Contribute도 환영한다.</p>
<p>다음 글 - <a href="/2016/10/02/typescript-basic-type">TypeScript: Basic Type</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>람다, 익명 함수, 클로저</title>
    <link href="https://hyunseob.github.io/2016/09/17/lambda-anonymous-function-closure/"/>
    <id>https://hyunseob.github.io/2016/09/17/lambda-anonymous-function-closure/</id>
    <published>2016-09-17T07:25:45.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/lambda-anonymous-function-closure.png"/><p>람다에 대한 부끄러운 에피소드가 하나 있다. 어떤 분이 페이스북 그룹에 JavaScript 콜백과, 람다함수, 클로저에 대해 물어보는 글을 올렸다. 난 당시 콜백과 클로저에 대해서는 어느정도 알고 있었지만 람다에 대해서는 구체적으로 아는 바가 없었다. 그래서 구글에 JavaScript Lambda를 검색해보니 어째 Arrow function 관련 내용만 나오기에 단순히 Arrow function에 대해 물어보는 것이로구나, 라고 생각하고 답변을 달았다. 다행히도 다른 분께서 람다에 대해서 지적을 해주셔서 해당 토픽에 대해 찾아보는 계기가 되었다. 이 글은 해당 페이스북 게시물을 참고하여 스스로 찾아본 람다에 대한 개념을 정리한 글이다.</p>
<hr>
<h2 id="람다-대수-Lambda-calculus"><a href="#람다-대수-Lambda-calculus" class="headerlink" title="람다 대수(Lambda calculus)"></a>람다 대수(Lambda calculus)</h2><p>현재 프로그래밍 언어에서 사용되고 있는 람다에 대하여 깊은 이해를 하고자 한다면 역시 이론적인 배경을 한 번쯤 짚어보는 것도 좋겠다. 현재 사용되고 있는 람다의 근간은 수학과 기초 컴퓨터과학 분야에서의 <em>람다 대수</em>이다. 람다 대수는 간단히 말하자면 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법이다.</p>
<p>람다 대수는 다음과 같은 특징이 있다.</p>
<ol>
<li>람다 대수는 이름을 가질 필요가 없다. (익명 함수)</li>
<li>두 개 이상의 입력이 있는 함수는 최종적으로 1개의 입력만 받는 람다 대수로 단순화 될 수 있다. (커링)</li>
</ol>
<p>더 많은 정보에 대해서는 <a href="https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98" target="_blank" rel="external">위키백과</a>에서 보다 자세한 정보를 찾아볼 수 있다.</p>
<h2 id="익명-함수-Anonymous-function"><a href="#익명-함수-Anonymous-function" class="headerlink" title="익명 함수(Anonymous function)"></a>익명 함수(Anonymous function)</h2><p>익명 함수는 람다 대수로부터 영향을 받아 만들어진 프로그래밍에서 함수를 표현하는 방식의 일종이다. 비교적 최근부터 대부분의 프로그래밍 언어가 익명 함수를 지원한다. 흔히 Java가 8버전 부터 람다를 지원하게 되었다고 하는데 이때 람다가 <em>익명 함수(Lambda abstraction)</em> 를 말한다.</p>
<p>각 언어별로 익명 함수를 표현하는 법은 제각기 다르지만, 공통적으로 가지는 특징이 있다. 바로 <em>일급 객체(First-class citizen)</em> 라는 점이다.</p>
<p>일급 객체는 함수의 인자로 넘겨받을 수도 있으며, 함수의 결과값으로 리턴할 수도 있고, 변수에 값을 할당할 수도 있다는 것을 말한다. 프로그래밍 언어에서 익명 함수는 애초에 다른 함수에 인자로 넘기거나 함수의 결과 값으로 리턴할 용도(이를테면 <code>map()</code>에 인자로 넘긴다던지, 클로저를 리턴한다던지)로 만들어지기 때문에 이런 특징을 갖게 되는 것이다. 또한 함수가 일급 객체가 되면 <em>일급 함수(First-class function)</em> 라고 부를 수 있다.</p>
<p>나는 익명함수이면서 일급함수라면 람다라고 부를 수 있다고 생각한다. 어떤 분은 람다는 순수함수여야 한다는 생각을 가지고 있기도 하지만, 이것은 위에서 다룬 수학적 의미의 람다에 가까운 것으로 프로그래밍 언어에서의 람다와는 거리가 있다는 게 내 생각이다. 물론 함수형 프로그래밍 패러다임에서는 순수함수여야겠지만 함수형 프로그래밍 패러다임에서는 람다가 아니라 모든 함수가 순수함수여야 한다.</p>
<p>아까 전에 각 언어별로 익명 함수를 표현하는 법이 제각기 다르다고 했는데, 그 차이가 가장 두드러지는 언어가 파이썬이다. 파이썬의 익명함수는 <em>문맥(Statement)</em> 이 아닌 <em>표현식(Expression)</em> 만을 지원한다. 즉, 파이썬의 익명함수는 블록을 가지지도 않고, 리턴하는 값만 표현하는 식 하나로만 구성된 다는 것이다. <a href="https://www.quora.com/What-is-lambda-function-in-Python-and-why-do-we-need-it" target="_blank" rel="external">Quora의 어떤 질문</a>의 답변에서 파이썬은 람다 함수(Lambda function)가 아니라 람다 표현식(Lambda expression)을 지원하는 것이라고 하는데 아주 적절한 표현이라고 생각한다.</p>
<p>이 글에서는 언어별로 람다를 설명하지는 않고, JavaScript에서의 람다에 대해서만 다룬다.</p>
<h3 id="JavaScript의-익명-함수"><a href="#JavaScript의-익명-함수" class="headerlink" title="JavaScript의 익명 함수"></a>JavaScript의 익명 함수</h3><p>위의 정의에 의하면 JavaScript의 모든 함수는 일급 객체이므로 JavaScript에서는 익명 함수이기만 하면 람다라고 볼 수 있겠다. 이렇게만 보면 사실 전혀 특별한 점이 없다. 왜냐하면 JavaScript에서 익명 함수는 일상적으로 사용하는 것이기 때문이다.</p>
<p>가장 흔한 용례로는 콜백을 꼽지 않을 수 없다. 콜백으로 Named function을 넘길 수도 있지만, 대개의 경우 일회용 함수를 넘기기 위해서 익명 함수를 사용하게 된다. 클로저도 마찬가지로 익명함수를 사용한다. 너무나 많은 용례가 있어 굳이 하나하나 꼽을 필요도 없을 것 같다.</p>
<p>ES2015에서는 Arrow function이 도입되면서 익명함수를 보다 람다스럽게(…) 표현할 수 있게 되었는데, 이 부분 문법 변화만 짚고 넘어가려고 한다.</p>
<p>먼저 ES5의 람다식이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ES5.1</span></div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Arrow function을 사용하면 다음과 같이 매우 간결하게 표현이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ES2015</span></div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> n * n);</div></pre></td></tr></table></figure>
<h2 id="람다와-클로저-Closure"><a href="#람다와-클로저-Closure" class="headerlink" title="람다와 클로저(Closure)"></a>람다와 클로저(Closure)</h2><p>전에 썼던 <a href="https://hyunseob.github.io/2016/08/30/javascript-closure/">게시물</a>에서 이미 JavaScript 클로저에 대해서 다룬 바 있지만, 클로저는 JavaScript에만 있는 개념이 아니다. 또한 클로저는 람다로부터 파생된 개념이다. 일단 다음의 예제를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">adder</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add5 = adder(<span class="number">5</span>);</div><div class="line">add5(<span class="number">10</span>); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p><code>add5</code>라는 함수의 입장에서 생각해볼 때, 자신의 스코프 내에 있는 <code>b</code>라는 변수는 인자로 받은 변수이고 해당 스코프 내에 갇혀있지만, <code>a</code>라는 변수는 대체 어디서 와서 사용되고 있는지 알 수가 없다. 이때의 <code>a</code>를 <em>자유 변수(Free variable)</em>, <code>b</code>를 <em>묶인 변수(Bound variable)</em> 라고 부른다.</p>
<p>위의 람다식에서는 자유 변수와 묶인 변수를 하나씩 사용하고 있다. 람다식은 사용하는 변수의 종류에 따라 두 종류로 나눌 수 있다. 바로 <em>닫힌 람다식(Closed expression)</em> 과 <em>열린 람다식(Open expression)</em> 이다.</p>
<p>람다 표현식에서 사용하는 변수들이 모두 <strong>묶인 변수</strong>일 때 닫힌 람다식이라고 부른다. 그리고 람다 표현식에서 사용하는 변수들 중 하나라도 <strong>자유 변수</strong>가 있을 때 열린 람다식이라고 부른다.</p>
<p>자, 이제 클로저를 아주 간단하게 설명할 수 있다. 클로저는 바로 열린 람다식을 닫힌 람다식으로 만드는 것이다. 클로저의 이름이 어떻게 유래되었는지도 예상이 될 것이다. 클로저는 람다식 내의 모든 자유 변수를 스코프 내로 가져와 묶는다. 그렇기 때문에 클로저는 만들어진 환경을 기억하는 것처럼 보인다.</p>
<h3 id="JavaScript의-클로저"><a href="#JavaScript의-클로저" class="headerlink" title="JavaScript의 클로저"></a>JavaScript의 클로저</h3><!-- ~~하지만 JavaScript의 클로저는 이 정의와는 약간 다른 모습을 보인다. 다음의 예제를 보자.~~ -->
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeAdder</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b + c;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add2 = freeAdder(<span class="number">2</span>);</div><div class="line">add2(<span class="number">3</span>); <span class="comment">// 6</span></div><div class="line"></div><div class="line">a = <span class="literal">undefined</span>;</div><div class="line">add2(<span class="number">3</span>); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<!-- ~~위의 예제에서 자유 변수는 `a`, `b`이다. 따라서 클로저의 정의대로 `a`와 `b`값을 클로저 스코프 내로 데려와서 묶었다면 바깥의 `a` 변수를 `undefined`로 정의했다고 한들, `add2(3)`은 똑같은 `6`을 리턴해야 하는데 실제로는 바뀐 `a`값의 영향을 받아 `NaN`을 리턴했다. 실제로 JavaScript의 클로저는 클로저가 정의된 그 스코프보다 상위 스코프의 자유 변수들은 바인딩하지 않는다. `b`같이 해당 스코프의 변수는 바인딩 된다.~~

~~이것은 JavaScript의 클로저가 제너럴한 클로저의 정의대로는 구현되지 않았다는 것을 의미한다. 왜 그렇게 구현되었는지, 이유까지는 찾아보지 않았지만 당연히 성능 문제(상위 스코프 탐색비용, 변수 저장비용)로 예상된다.~~ -->
<p><strong>수정: 글 내용에 오류가 발견되어 수정하였습니다.</strong></p>
<p>위의 예제는 앞서 설명했던 케이스에 글로벌 변수인 <code>a</code>가 추가되었다. 그런데 클로저의 입장에서 보면 <code>b</code>도 자유 변수이고, <code>a</code>도 자유 변수이므로 똑같이 묶어야 할 것으로 보인다. 하지만 위에서 본 대로 실제 동작은 그렇지 않다. JavaScript에서는 클로저를 만들면 클로저가 만들었을 때의 환경이 만들어지는데, 위의 경우에서는 생성당시의 환경에 <code>b</code>라는 변수는 존재했지만 <code>a</code>라는 변수는 단지 참조만 하고 있었으므로 클로저에도 동일한 환경이 구성된다는 것이다. 따라서 스코프체인에 상위 스코프가 포함되어 있으므로 상위 스코프에서 <code>a</code>를 탐색하여 참조하게 된다.</p>
<h2 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">Lambda calculus</a> - Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="external">Anonymous function</a> - Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">First-class function</a> - Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">Higher-order function</a> - Wikipedia</li>
<li><a href="http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda" target="_blank" rel="external">What is the difference between a ‘closure’ and a ‘lambda’?</a> - StackOverflow</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/lambda-anonymous-function-closure.png&quot;/&gt;&lt;p&gt;람다에 대한 부끄러운 에피소드가 하나 있다. 어떤 분이 페이스북 그룹에 JavaScript 콜백과, 람다함수, 클로저에 대해 물어보는 글을 올
    
    </summary>
    
      <category term="ComputerScience" scheme="https://hyunseob.github.io/categories/ComputerScience/"/>
    
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/tags/JavaScript/"/>
    
      <category term="ES2015" scheme="https://hyunseob.github.io/tags/ES2015/"/>
    
      <category term="Closure" scheme="https://hyunseob.github.io/tags/Closure/"/>
    
      <category term="Terminology" scheme="https://hyunseob.github.io/tags/Terminology/"/>
    
      <category term="ComputerScience" scheme="https://hyunseob.github.io/tags/ComputerScience/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 클로저(Closure)</title>
    <link href="https://hyunseob.github.io/2016/08/30/javascript-closure/"/>
    <id>https://hyunseob.github.io/2016/08/30/javascript-closure/</id>
    <published>2016-08-29T16:00:59.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/javascript-closure.png"/><h2 id="클로저란"><a href="#클로저란" class="headerlink" title="클로저란?"></a>클로저란?</h2><p>MDN에서는 클로저를 다음과 같이 정의하고 있다.</p>
<blockquote>
<p>클로저는 독립적인 (자유) 변수를 가리키는 함수이다. 또는, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’.</p>
</blockquote>
<p>흔히 함수 내에서 함수를 정의하고 사용하면 클로저라고 한다. 하지만 대개는 정의한 함수를 리턴하고 사용은 바깥에서 하게된다. 말로 설명하면 설명하기가 복잡하니 우선 코드를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClosure</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = <span class="string">'variable 1'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> text;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> closure = getClosure();</div><div class="line"><span class="built_in">console</span>.log(closure()); <span class="comment">// 'variable 1'</span></div></pre></td></tr></table></figure>
<p>위에서 정의한 <code>getClosure()</code>는 함수를 반환하고, 반환된 함수는 <code>getClosure()</code> 내부에서 선언된 변수를 참조하고 있다. 또한 이렇게 참조된 변수는 함수 실행이 끝났다고 해서 사라지지 않았고, 여전히 제대로 된 값을 반환하고 있는 걸 알 수 있다.</p>
<p>여기서 반환된 함수가 클로저인데, MDN에서 정의된 내용에서도 말했듯 환경을 기억하고 있는 것처럼 보인다. 아직은 잘 이해가 되지 않으니, 다른 예제도 한 번 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> base = <span class="string">'Hello, '</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHelloTo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = base + name;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello1 = sayHelloTo(<span class="string">'승민'</span>);</div><div class="line"><span class="keyword">var</span> hello2 = sayHelloTo(<span class="string">'현섭'</span>);</div><div class="line"><span class="keyword">var</span> hello3 = sayHelloTo(<span class="string">'유근'</span>);</div><div class="line">hello1(); <span class="comment">// 'Hello, 승민'</span></div><div class="line">hello2(); <span class="comment">// 'Hello, 현섭'</span></div><div class="line">hello3(); <span class="comment">// 'Hello, 유근'</span></div></pre></td></tr></table></figure>
<p>출력된 결과를 보면 <code>text</code> 변수가 동적으로 변화하고 있는 것처럼 보인다. 실제로는 <code>text</code>라는 변수 자체가 여러 번 생성된 것이다. 즉, <code>hello1()</code>과 <code>hello2()</code>, <code>hello3()</code>은 서로 다른 환경을 가지고 있다.</p>
<h2 id="클로저를-통한-은닉화"><a href="#클로저를-통한-은닉화" class="headerlink" title="클로저를 통한 은닉화"></a>클로저를 통한 은닉화</h2><p>일반적으로 JavaScript에서 객체지향 프로그래밍을 말한다면 <code>Prototype</code>을 통해 객체를 다루는 것을 말한다. ES2015에는 클래스도 있지만 이걸 이야기하면 너무 삼천포로 빠지므로 넘어가도록 하고..</p>
<p>여하튼 <code>Prototype</code>을 통한 객체를 만들 때의 주요한 문제 중 하나는 Private variables에 대한 접근 권한 문제이다. 예제 코드를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Hello.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + <span class="keyword">this</span>._name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello1 = <span class="keyword">new</span> Hello(<span class="string">'승민'</span>);</div><div class="line"><span class="keyword">var</span> hello2 = <span class="keyword">new</span> Hello(<span class="string">'현섭'</span>);</div><div class="line"><span class="keyword">var</span> hello3 = <span class="keyword">new</span> Hello(<span class="string">'유근'</span>);</div><div class="line"></div><div class="line">hello1.say(); <span class="comment">// 'Hello, 승민'</span></div><div class="line">hello2.say(); <span class="comment">// 'Hello, 현섭'</span></div><div class="line">hello3.say(); <span class="comment">// 'Hello, 유근'</span></div><div class="line">hello1._name = <span class="string">'anonymous'</span>;</div><div class="line">hello1.say(); <span class="comment">// 'Hello, anonymous'</span></div></pre></td></tr></table></figure>
<p>위에서 <code>Hello()</code>로 생성된 객체들은 모두 <code>_name</code>이라는 변수를 가지게 된다. 변수명 앞에 underscore(_)를 포함했기 때문에 일반적인 JavaScript 네이밍 컨벤션을 생각해 봤을때 이 변수는 Private variable으로 쓰고싶다는 의도를 알 수 있다. 하지만 실제로는 여전히 외부에서도 쉽게 접근가능한 변수일 뿐이다.</p>
<p>이 경우에 클로저를 사용하여 외부에서 변수에 직접 접근하는 것을 제한할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _name = name;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + _name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello1 = hello(<span class="string">'승민'</span>);</div><div class="line"><span class="keyword">var</span> hello2 = hello(<span class="string">'현섭'</span>);</div><div class="line"><span class="keyword">var</span> hello3 = hello(<span class="string">'유근'</span>);</div><div class="line"></div><div class="line">hello1(); <span class="comment">// 'Hello, 승민'</span></div><div class="line">hello2(); <span class="comment">// 'Hello, 현섭'</span></div><div class="line">hello3(); <span class="comment">// 'Hello, 유근'</span></div></pre></td></tr></table></figure>
<p>특별히 인터페이스를 제공하는 것이 아니라면, 여기서는 외부에서 <code>_name</code>에 접근할 방법이 전혀 없다. 이렇게 은닉화도 생각보다 쉽게 해결할 수 있다.</p>
<h2 id="반복문-클로저"><a href="#반복문-클로저" class="headerlink" title="반복문 클로저"></a>반복문 클로저</h2><p>닳고 닳은 예제이긴 하지만, 그렇다고 빠트리긴 아쉬운 예제이므로 여기서도 한 번 짚고 넘어가야 할 것 같다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>간단하게 0-9까지의 정수를 출력하는 코드이지만 실제로 돌려보면 엉뚱하게도 10만 열 번 출력되는 걸 볼 수 있다. 왜일까?</p>
<p>먼저 <code>setTimeout()</code>에 인자로 넘긴 익명함수는 모두 0.1초 뒤에 호출될 것이다. 그 0.1초 동안에 이미 반복문이 모두 순회되면서 <code>i</code>값은 이미 10이 된 상태. 그 때 익명함수가 호출되면서 이미 10이 되어버린 <code>i</code>를 참조하는 것이다.</p>
<p>이 경우에도 클로저를 사용하면 원하는 대로 동작하도록 만들 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>중간에 IIFE를 덧붙여 <code>setTimeout()</code>에 걸린 익명함수를 클로저로 만들었다. 앞서 말한대로 클로저는 만들어진 환경을 기억한다. 이 코드에서 <code>i</code>는 IIFE내에 <code>j</code>라는 형태로 주입되고, 클로저에 의해 각기 다른 환경속에 포함된다. 반복문은 10회 반복되므로 10개의 환경이 생길 것이고, 10개의 서로 다른 환경에 10개의 서로 다른 j가 생긴다.</p>
<p>이쯤에서 IIFE 매개변수로 <code>i</code>를 넘기지 않고 그냥 직접 참조해도 되지 않느냐는 의문이 들 수도 있다. 하지만 직접 그렇게 해보면 원하는 대로 동작하지 않는다. <del>클로저는 바로 바깥의 환경(스코프)만 복사하기 때문이다. 그 윗단계의 함수 스코프는 그냥 참조한다. 따라서 위에서는 반드시 IIFE 내에 복사할 용도의 변수가 하나는 정의되어야 한다. 물론 위처럼 매개변수로 넘겨받은 인자더라도 상관은 없다.</del></p>
<p>수정: 위의 이유 설명문단에서 오류가 발견되어 덧붙인다. 위의 예제에서는 IIFE를 통해서 클로저마다 환경이 생긴다. 하지만 인자로 <code>i</code>를 넘기지 않는다면 당연히 클로저가 참조하는 IIFE의 함수 스코프에서도 <code>i</code>값이 없으므로 생성 당시의 외부 스코프인 글로벌을 탐색하게 되고 결국 모두 같은 <code>i</code>를 참조하게 된다. 반면에, 인자로 <code>i</code>를 넘기게 되면 IIFE로 만든 10개의 스코프에 모두 <code>i</code>라는 변수가 다른 값으로 생기므로 정상적으로 동작할 수 있는 것이다.</p>
<p>참고로 여기서 콜백으로 넘기는 함수 자체를 IIFE로 만들면 되지 않느냐는 사람도 있는데, 그렇게 하면 원하는대로 0-9까지 출력은 되지만 함수 내부가 즉시 실행되어 버리므로 <code>setTimeout()</code>의 0.1초 딜레이가 작동하지 않게 된다.</p>
<h2 id="클로저의-성능"><a href="#클로저의-성능" class="headerlink" title="클로저의 성능"></a>클로저의 성능</h2><p>클로저는 각자의 환경을 가진다. 이 환경을 기억하기 위해서는 당연히 메모리가 소모될 것이다. 클로저를 생성해놓고 참조를 제거하지 않는 것은 C++에서 동적할당으로 객체를 생성해놓고 <code>delete</code>를 사용하지 않는 것과 비슷하다. 클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않는다. 따라서 클로저 사용이 끝나면 참조를 제거하는 것이 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _name = name;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + _name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello1 = hello(<span class="string">'승민'</span>);</div><div class="line"><span class="keyword">var</span> hello2 = hello(<span class="string">'현섭'</span>);</div><div class="line"><span class="keyword">var</span> hello3 = hello(<span class="string">'유근'</span>);</div><div class="line"></div><div class="line">hello1(); <span class="comment">// 'Hello, 승민'</span></div><div class="line">hello2(); <span class="comment">// 'Hello, 현섭'</span></div><div class="line">hello3(); <span class="comment">// 'Hello, 유근'</span></div><div class="line"></div><div class="line"><span class="comment">// 여기서 메모리를 release 시키기 클로저의 참조를 제거해야 한다.</span></div><div class="line">hello1 = <span class="literal">null</span>;</div><div class="line">hello2 = <span class="literal">null</span>;</div><div class="line">hello3 = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>이처럼 메모리 관리에 있어서 약점이 있지만 추가로 스코프 체인을 검색하는 시간과 새로운 스코프를 생성하는데 드는 비용도 감안하지 않을 수 없다. 이 부분에 대해서는 JavaScript 스코프를 주제로 하는 별도의 글에서 다룰 것이다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>클로저에 대해 설명하는 문서가 워낙 많아서 포스팅을 꼭 해야하나 의문이 있었는데, 얼마 전 클로저에 대한 질문을 받고 속 시원한 대답을 하지 못했다. <a href="https://hyunseob.github.io/2016/02/21/how-to-become-a-great-frontend-engineer/">탁월한 프론트엔드 엔지니어가 되는 법</a>에서도 말했지만 아직 기록한 적이 없으므로 이해하지 못했다는 사실도 깨닫지 못한 것 같다. 때문에 이번에 한 번 정리하는 기회를 갖고 클로저를 잘 이해해보고자 했다. 다음에는 JavaScript의 복잡한 개념 중 하나인 Scope에 대해서도 자세히 다뤄 볼 것이다.</p>
<h2 id="글-쓰며-참고한-문서"><a href="#글-쓰며-참고한-문서" class="headerlink" title="글 쓰며 참고한 문서"></a>글 쓰며 참고한 문서</h2><p>잠깐 구글링 해봐도 양질의 문서들이 많이 나온다.</p>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external">클로져 - MDN</a></li>
<li><a href="http://blog.javarouka.me/2012/01/closure.html" target="_blank" rel="external">클로저 사용에는 주의가 필요합니다</a></li>
<li><a href="http://blog.javarouka.me/2012/01/javascripts-closure.html" target="_blank" rel="external">자바스크립트의 클로저</a></li>
<li><a href="http://meetup.toast.com/posts/86" target="_blank" rel="external">자바스크립트의 스코프와 클로저 - Toast Meetup</a></li>
<li><a href="http://meetup.toast.com/posts/90" target="_blank" rel="external">클로저, 그리고 캡슐화와 은닉화 - Toast Meetup</a></li>
<li><a href="http://unikys.tistory.com/309" target="_blank" rel="external">Closure 쉽게 이해하기 / 실용예제소스</a></li>
<li><a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="external">How do JavaScript closures work? - StackOverflow</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/javascript-closure.png&quot;/&gt;&lt;h2 id=&quot;클로저란&quot;&gt;&lt;a href=&quot;#클로저란&quot; class=&quot;headerlink&quot; title=&quot;클로저란?&quot;&gt;&lt;/a&gt;클로저란?&lt;/h2&gt;&lt;p&gt;MDN에서는 클로저를 다음과 같
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="Basic" scheme="https://hyunseob.github.io/categories/JavaScript/Basic/"/>
    
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/tags/JavaScript/"/>
    
      <category term="Closure" scheme="https://hyunseob.github.io/tags/Closure/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 프록시(Proxy)</title>
    <link href="https://hyunseob.github.io/2016/08/17/javascript-proxy/"/>
    <id>https://hyunseob.github.io/2016/08/17/javascript-proxy/</id>
    <published>2016-08-16T15:27:28.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/javascript-proxy.png"/><h2 id="Proxy-As-a-Design-Pattern"><a href="#Proxy-As-a-Design-Pattern" class="headerlink" title="Proxy As a Design Pattern"></a>Proxy As a Design Pattern</h2><blockquote>
<p>프록시는 일반적으로 다른 어떤 클래스의 인터페이스로 동작하는 클래스이다. (중략) 요컨대, 프록시는 내부적으로 실제의 객체(real subject)에 접근할 때 호출되는 래퍼(wrapper) 혹은 대리 객체다.<br>– <a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="external">위키피디아(영문)</a></p>
</blockquote>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>상황을 가정해보자. 우선 다음과 같이 전화번호부 객체가 구현되어있는 상태이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneBook</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dictionary = &#123;</div><div class="line">    <span class="string">'이승민'</span>: <span class="string">'01012341234'</span>,</div><div class="line">    <span class="string">'이현섭'</span>: <span class="string">'01023456789'</span>,</div><div class="line">    <span class="string">'오유근'</span>: <span class="string">'01077777777'</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PhoneBook.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    callback(self.dictionary[name]);</div><div class="line">  &#125;, <span class="number">3000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 전화번호부 클래스의 <code>get()</code>이 호출될 때마다, 조회수를 따로 기록하여 저장하고 싶다면 어떡해야 할까? 전화번호부 클래스의 코드를 고치는 것은 예상치못한 사이드 이펙트를 초래할 수 있기 때문에 지양하고 싶다.</p>
<p>이런 경우에 프록시 패턴을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneBookProxy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> phoneBook = <span class="keyword">new</span> PhoneBook();</div><div class="line">  <span class="keyword">var</span> viewCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>) </span>&#123;</div><div class="line">      viewCount++;</div><div class="line">      phoneBook.get(name, callback);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">getViewCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> viewCount;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와 같이 프록시 객체를 구현해서 조회수를 따로 저장하고 <code>PhoneBook</code>을 대리하는 객체로 <code>PhoneBookProxy</code>를 사용하면 된다. 이 때 프록시 클래스는 공개된 인터페이스인 <code>get()</code>메소드를 반드시 구현해야 한다.</p>
<h3 id="Proxy-for-Caching"><a href="#Proxy-for-Caching" class="headerlink" title="Proxy for Caching"></a>Proxy for Caching</h3><p>위의 <code>PhoneBook</code> 객체는 하나의 전화번호를 얻기 위해서는 무려 3초를 기다려야 한다. 따라서 캐시를 이용해 좀 더 빠르게 해볼 수 있을 것이다. 이 때도 프록시 패턴을 활용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneBookProxy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> phoneBook = <span class="keyword">new</span> PhoneBook();</div><div class="line">  <span class="keyword">var</span> viewCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>) </span>&#123;</div><div class="line">      viewCount++;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (cache[name]) &#123;</div><div class="line">        callback(cache[name]);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        phoneBook.get(name, <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">          cache[name] = number;</div><div class="line">          callback(number);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">getViewCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> viewCount;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>아까 만든 프록시 객체에 캐시를 저장하는 변수를 추가하고, <code>get()</code> 메소드에 캐시를 검사하는 로직만 추가하면 된다. 프록시 객체를 통해서 <code>get()</code>을 호출하면 2번째 요청부터는 캐시로부터 데이터를 반환할 수 있다.</p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="$.proxy()"></a><a href="https://api.jquery.com/jQuery.proxy/" target="_blank" rel="external">$.proxy()</a></h2><p>jQuery에서는 동명의 메소드를 구현하고 있다. jQuery의 <code>$.proxy()</code> 메소드는 함수 내부의 <code>this</code> 컨텍스트를 바꾸는 ES5의 <code>bind()</code>와 비슷한 동작을 한다. 실제 <a href="https://github.com/jquery/jquery/blob/6acf4a79467a5aea5bc1eb7d552d72366718635d/src/core.js#L420" target="_blank" rel="external">jQuery의 구현 코드</a>를 보면 컨텍스트를 바꿔주는 <code>apply()</code>와 <code>call()</code>을 사용하고 있는 걸 볼 수 있다. 하지만 컨텍스트를 바꾸어 주는 것 이외에는 원래 함수에 별다른 커스터마이징을 할 수가 없다. 원래 그런 용도가 아니기 때문.<br>여기에서는 오히려 특정 함수의 대상이 되는 객체가 프록시 된다. 따라서 앞서 소개한 프록시 패턴과는 다른 종류라고 볼 수 있다. 물론 의미적으로 프록시라는 말은 적절하다.</p>
<h2 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">ES2015 Proxy</a></h2><p>지원률이 낮아 당장 써먹긴 어렵지만, ES2015에도 <code>Proxy</code>라는 타입이 추가되었다. 이 타입은 대상이 되는 객체에 대해서 JavaScript 문법 레벨의 요청(할당문 같은)조차도 가로챌 수 있는 강력한 기능을 제공한다. <a href="http://hacks.mozilla.or.kr/2016/03/es6-in-depth-proxies-and-reflect/" target="_blank" rel="external">ES6 in depth</a>에서 잘 설명하고 있다. 이걸 잘 이해하면 일반적인 프록시 디자인 패턴의 이해에도 도움이 될 것이다. 이 글에서 다루기엔 글이 너무 길어질 것 같아 추후에 다시 다뤄볼 예정이다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>프록시 패턴은 몇 가지 잘 알려진 유즈케이스가 있긴하지만, 넓게 보면 인터페이스가 동일한, 같은 결과를 반환하는 래퍼정도로 정의할 수 있을 것 같다. 이 글에서는 모든 유즈케이스를 다루지는 않았으니 아래의 참고링크를 참고해보면 도움이 될 것이다.(일반적인 다른 언어의 유즈케이스랑 크게 다르지 않음) 개인적으로는 학교에서 알량하게 배웠던 패턴을 다시금 나의 제 1언어가 된 JavaScript를 통해 다시 구현해보니 해당 패턴에 대한 이해도가 조금 높아진 것 같다.</p>
<h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul>
<li><a href="http://www.dofactory.com/javascript/proxy-design-pattern" target="_blank" rel="external">Proxy JavaScript Pattern with Example</a></li>
<li><a href="https://lostechies.com/derickbailey/2012/03/29/proxies-and-decorators-in-javascript/" target="_blank" rel="external">Proxies And Decorators In JavaScript</a></li>
<li><a href="http://www.joezimjs.com/javascript/javascript-design-patterns-proxy/" target="_blank" rel="external">JavaScript Design Pattern: Proxy</a></li>
<li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#proxypatternjquery" target="_blank" rel="external">Proxy - Learning JavaScript Design Patterns
</a>(Ebook) - <code>$.proxy</code>를 다루고 있다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/javascript-proxy.png&quot;/&gt;&lt;h2 id=&quot;Proxy-As-a-Design-Pattern&quot;&gt;&lt;a href=&quot;#Proxy-As-a-Design-Pattern&quot; class=&quot;headerlink&quot; title=&quot;P
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="DesignPattern" scheme="https://hyunseob.github.io/categories/JavaScript/DesignPattern/"/>
    
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/tags/JavaScript/"/>
    
      <category term="DesignPattern" scheme="https://hyunseob.github.io/tags/DesignPattern/"/>
    
      <category term="jQuery" scheme="https://hyunseob.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>[underscore] extend 올바르게 사용하기</title>
    <link href="https://hyunseob.github.io/2016/07/23/underscore-extend/"/>
    <id>https://hyunseob.github.io/2016/07/23/underscore-extend/</id>
    <published>2016-07-23T07:57:15.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/underscore-extend.jpg"/><p>객체를 확장하는 <code>extend()</code>는 복사용도로도 쓸 수 있는 정말 편리한 메소드지만, 사용하면서 주의할 점이 하나 있는데, 바로 인자 순서이다.</p>
<p>예를 들어, 여러 명의 사람 정보를 저장한 배열에 똑같은 프로퍼티를 추가하는 로직을 짠다고 가정하자. 물론  이 경우 <code>extend()</code>를 사용해야할 필요는 없지만, 굳이 사용해야만 하는 상황이라고 가정하자. 그러면 다음과 같이 코드를 짤 수 있을 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> people = [&#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'이현섭'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">27</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'이승민'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">28</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'오유근'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">26</span></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="keyword">let</span> base = &#123; <span class="attr">home</span>: <span class="string">'한강빌리지'</span> &#125;;</div><div class="line"></div><div class="line">people = people.map(<span class="function">(<span class="params">person</span>) =&gt;</span> _.extend(base, person));</div></pre></td></tr></table></figure>
<p>언뜻 봐서는 적절한 코드로 보인다. 하지만 이 코드를 실행시키면 배열 내 모든 객체의 데이터가 동일한 데이터로 변경되는 문제가 생긴다.</p>
<p>왜일까? 이유는 인자의 순서에 따라 <code>extend()</code>의 결과물이 다르기 때문이다. underscore의 문서를 다시보면,</p>
<blockquote>
<p><strong>extend</strong> <code>_.extend(destination, *sources)</code></p>
<p><strong>source</strong> 객체에 있는 모든 프로퍼티를 <strong>destination</strong> 객체에 복사하고, <strong>destination</strong> 객체를 리턴합니다. source는 순서대로 처리하므로, 마지막 source의 프로퍼티가 앞의 인자들이 가진 같은 이름의 프로퍼티를 덮어쓸 수 있습니다.</p>
</blockquote>
<p>이 서술에 의하면, 앞에서 예로 든 코드는 <code>base</code>라는 변수를 확장하고 리턴하게 된 것이다. 게다가 <code>extend()</code> 메소드는 새로운 객체를 만들어 리턴하지 않고, 주어진 객체를 확장하기 때문에 이 경우에는 <code>base</code>가 확장되고 리턴되는 것만 세 번 반복되는 것이다. 따라서 새롭게 만들어진 배열은 그냥 <code>base</code>가 세 번 연속 <code>extend()</code>된 결과물 일 뿐이다.</p>
<p>코드가 의도한 대로 동작하도록 바꾸려면 그냥 인자 순서만 교체해주면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">people = people.map(<span class="function">(<span class="params">person</span>) =&gt;</span> _.extend(person, base));</div></pre></td></tr></table></figure>
<p>위의 사항은 동일한 용도인 <a href="https://lodash.com/docs#assignIn" target="_blank" rel="external">lodash의 assignIn()</a>, <a href="https://api.jquery.com/jquery.extend/" target="_blank" rel="external">jQuery의 extend()</a>에서도 동일하다.</p>
<p>“extend는 매개변수의 순서에 유의해서 사용해라”라는 말로 축약될 수 있는 이야기를 이렇게 늘어 놓을 필요가 있나 싶지만, 이 문제로 몇 시간 가량을 날려먹었기 때문에 이렇게 포스팅 기록을 남긴다. 역시 API 문서는 영어라고 읽기 싫다고 넘기지말고 주의 깊게 보아야겠다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/underscore-extend.jpg&quot;/&gt;&lt;p&gt;객체를 확장하는 &lt;code&gt;extend()&lt;/code&gt;는 복사용도로도 쓸 수 있는 정말 편리한 메소드지만, 사용하면서 주의할 점이 하나 있는데, 바로 인자 순서이다.&lt;/p
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="lodash/underscore" scheme="https://hyunseob.github.io/categories/JavaScript/lodash-underscore/"/>
    
    
      <category term="underscore.js" scheme="https://hyunseob.github.io/tags/underscore-js/"/>
    
      <category term="jQuery" scheme="https://hyunseob.github.io/tags/jQuery/"/>
    
      <category term="lodash" scheme="https://hyunseob.github.io/tags/lodash/"/>
    
  </entry>
  
  <entry>
    <title>Assert: Node.js 테스트 모듈</title>
    <link href="https://hyunseob.github.io/2016/05/09/assert-nodejs-test-module/"/>
    <id>https://hyunseob.github.io/2016/05/09/assert-nodejs-test-module/</id>
    <published>2016-05-08T17:43:53.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/assert-nodejs-test-module.jpg"/><p>요즘은 TDD니, BDD니 해서 테스트의 중요성이 더 없이 강조되고 있다. 워낙 많이 언급되다 보니 여지껏 테스트 코드를 작성할 일이 없었던 나도 조금은 공부해야겠다는 생각이 들었다. 방대한 라이브러리를 품고 있는 JavaScript 생태계답게, 테스트 관련 라이브러리나 프레임워크도 다양하지만 일단은 Node.js에서 포함하고 있는 기본적인 모듈인 Assert를 정리해봤다.</p>
<p><a href="https://nodejs.org/api/assert.html" target="_blank" rel="external">Assert</a>는 유닛 테스트를 위해서 Node.js에서 사용할 수 있는 테스트 모듈이다. 별도의 설치없이도 다음처럼 import하면 바로 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div></pre></td></tr></table></figure>
<p>유닛 테스트는 특정 모듈이 예상한 대로 돌아가는 지 검증하는 것이 목표이므로 다음과 같이 요상한 모듈이 있다고 가정한다(..)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// just-module.js</span></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line">exports = <span class="built_in">module</span>.exports;</div><div class="line"></div><div class="line">exports.returnFalse = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 <code>just-module</code> 이라는 녀석이 가지고 있는 <code>returnFalse()</code>라는 메소드는 호출 할 때마다 매 번 <code>false</code>를 반환하는 놀라운 메소드이다(..)</p>
<h2 id="메소드"><a href="#메소드" class="headerlink" title="메소드"></a>메소드</h2><h3 id="assert-ok-ifError"><a href="#assert-ok-ifError" class="headerlink" title="assert() / ok() / ifError()"></a>assert() / ok() / ifError()</h3><p><code>assert</code>는 그 자체가 테스트용 함수이기도 하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert(justModule.returnFalse()); <span class="comment">// throw AssertionError!</span></div><div class="line">assert.ok(justModule.returnFalse()); <span class="comment">// assert()의 alias임.</span></div><div class="line">assert.ifError(justModule.returnFalse()) <span class="comment">// Pass</span></div></pre></td></tr></table></figure>
<p><code>ok()</code>는 <code>assert()</code>의 alias 이므로 똑같이 동작한다. <code>ifError()</code>는 <code>assert()</code>와 반대로 인자로 넘어온 값이 <code>false</code>랑 같은 지 비교한 후 같지 않으면 에러를 발생시킨다.</p>
<p>위 코드를 실행하면 <code>AssertionError</code>를 발생시키며 프로그램이 종료된다. <code>assert()</code>는 인자로 넘어온 값이 <code>true</code>랑 같은 지 비교한 후, 같지 않으면 에러를 발생시키기 때문이다.</p>
<p>다음처럼 변경하면 에러가 일어나지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert(justModule.returnFalse() == <span class="literal">false</span>); <span class="comment">// Pass</span></div><div class="line">assert.ok(!justModule.returnFalse()); <span class="comment">// Pass</span></div><div class="line">assert.ifError(justModule.returnFalse()); <span class="comment">// Pass</span></div></pre></td></tr></table></figure>
<h3 id="equal-notEqual"><a href="#equal-notEqual" class="headerlink" title="equal() / notEqual()"></a>equal() / notEqual()</h3><p><code>equal()</code>과 <code>notEqual()</code>은 인자를 두 개 넘겨서 비교할 수 있는 메소드이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.equal(justModule.returnFalse(), <span class="string">''</span>); <span class="comment">// Pass</span></div><div class="line">assert.notEqual(justModule.returnFalse(), [<span class="number">0</span>]); <span class="comment">// throw AssertionError!</span></div></pre></td></tr></table></figure>
<p>응? 눈치가 빠른 분이라면 코드가 왜 이따구인지 감이 오실 것이다. 그렇다. <code>equal()</code>과 <code>notEqual()</code>은 비교할 때 <code>==</code>와 <code>!=</code>를 사용한다! 강제 형변환을 한 뒤에 비교하는 것이다. <code>==</code>와 <code>===</code>의 차이에 대해 잘 모른다면 <a href="https://hyunseob.github.io/2015/07/30/diffrence-between-equality-and-identity-in-javascript/">이 글</a>을 참고하면 좋다. (무려 블로그의 첫 글..)</p>
<p>아무튼, JavaScript의 강제 형변환을 별로 좋아하지 않는 사람이라면 이걸로 테스팅하기에는 뭔가 찜찜할 것이다. 하지만 역시 Assert는 <code>===</code>와 <code>!==</code>로 비교하는 메소드도 가지고 있다.</p>
<h3 id="strictEqual-notStrictEqual"><a href="#strictEqual-notStrictEqual" class="headerlink" title="strictEqual() / notStrictEqual()"></a>strictEqual() / notStrictEqual()</h3><p><code>strictEqual()</code>과 <code>notStrictEqual()</code>은 Identity 연산자로 비교한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.strictEqual(justModule.returnFalse(), <span class="string">''</span>); <span class="comment">// throw AssertionError!</span></div><div class="line">assert.notStrictEqual(justModule.returnFalse(), [<span class="number">0</span>]); <span class="comment">// Pass</span></div></pre></td></tr></table></figure>
<p>이제 <code>===</code>와 <code>!==</code>로 비교하므로 조금 더 명확한 비교가 가능해졌다!</p>
<h3 id="deepEqual-notDeepEqual"><a href="#deepEqual-notDeepEqual" class="headerlink" title="deepEqual() / notDeepEqual()"></a>deepEqual() / notDeepEqual()</h3><p>여기까지만 읽으면 <code>equal()</code>이든 <code>strictEqual()</code>이든 그냥 <code>==</code>나 <code>===</code> 쓰면 되는 거 아닌가? 싶은 생각이 들 수 있다. 사실 맞다. 가독성 외에는 큰 차이가 없다. 하지만 <code>deepEqual()</code>과 <code>notDeepEqual()</code>은 조금 더 편리한 기능을 제공한다.</p>
<p>먼저, 테스트를 위해 모듈에 조금 더 고수준의 함수를 구현해보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// just-module.js</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">exports.getObject = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>justModule</code>이라는 모듈에 <code>getObject()</code>라는 몹시 복잡한 작업을 하는 함수가 추가되었다(…) 그리고 테스트 코드를 작성한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.equal(justModule.getObject(), justModule.getObject()); <span class="comment">// throw AssertionError!</span></div><div class="line">assert.notEqual(justModule.getObject(), justModule.getObject()); <span class="comment">// Pass</span></div></pre></td></tr></table></figure>
<p>우리가 짠 함수는 항상 똑같이 생긴 객체를 반환하는데, 이상하게도 <code>equal()</code>을 사용한 비교에서 <code>AssertionError</code>를 발생시키고 <code>notEqual()</code>에서 통과된다. 그렇다. 아시다시피 객체의 변수는 참조만을 저장하고, 반환된 두 개의 객체는 서로 참조하고 있는 객체가 다르므로 에러가 발생할 수 밖에 없는 것이다. <a href="https://hyunseob.github.io/2016/02/08/copy-object-in-javascript/">이 글</a>을 참조.</p>
<p>이렇게 객체는 <code>equal()</code>으로 비교하면 안된다. 따라서 이런 때에 <code>deepEqual()</code>이나 <code>notDeepEqual()</code>을 사용할 수 있다. <code>deepEqual()</code>은 객체 내부까지 비교해서 일치여부를 체크하는 메소드이다. 위 코드는 다음과 같이 고칠 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.deepEqual(justModule.getObject(), justModule.getObject()); <span class="comment">// Pass</span></div><div class="line">assert.notDeepEqual(justModule.getObject(), justModule.getObject()); <span class="comment">// throw AssertionError!</span></div></pre></td></tr></table></figure>
<p>이제 예상대로 잘 동작한다!</p>
<h3 id="deepStrictEqual-notDeepStrictEqual"><a href="#deepStrictEqual-notDeepStrictEqual" class="headerlink" title="deepStrictEqual() / notDeepStrictEqual()"></a>deepStrictEqual() / notDeepStrictEqual()</h3><p><code>deepStrictEqual()</code>과 <code>notDeepStrictEqual()</code>이 무슨 메소드인지는 대충 짐작이 갈 것이다. <code>deepEqual()</code>과 <code>notDeepEqual()</code>이 Equality 연산자(<code>==</code>, <code>!=</code>)로 비교하므로 Identity 연산자(<code>===</code>, <code>!==</code>)를 통해 깊은 비교를 할 수 있도록 해주는 메소드이다. ‘deep’과 ‘strict’ 모두 앞에 다룬 내용이므로 예제는 패스.</p>
<p>다만, 한 가지 주의할 점이 있는데, 이 메소드들은 Old Node.js에서는 지원하지 않는다는 것이다. v0.10, v0.12에서는 사용할 수 없으며 v4.x부터 지원한다. 따라서 테스트 코드가 오래된 버전의 Node.js에서도 돌아야 한다면 <a href="https://github.com/sindresorhus/core-assert" target="_blank" rel="external">core-assert</a>라는 라이브러리를 사용하면 된다.</p>
<h3 id="throws-doesNotThrow"><a href="#throws-doesNotThrow" class="headerlink" title="throws() / doesNotThrow()"></a>throws() / doesNotThrow()</h3><p><code>throws()</code>와 <code>doesNotThrow()</code>는 인자로 넘긴 함수 블록이 에러를 throw 하는 지 체크하는 메소드다. 테스트를 위해 모듈에 무조건 에러를 던지는 메소드를 구현한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// just-module.js</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">exports.throwError = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  abc(def); <span class="comment">// ReferenceError expected</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>당연하지만, <code>throwError()</code>라는 메소드에서 <code>abc</code>와 <code>def</code>는 존재하지 않는 변수이므로 ReferenceError를 발생시킬 것이다.</p>
<p><code>throws()</code> 메소드는 아래처럼 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.throws(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  justModule.throwError(); <span class="comment">// throw ReferenceError</span></div><div class="line">&#125;); <span class="comment">// but pass</span></div></pre></td></tr></table></figure>
<p>이 코드를 실행시키면 ReferenceError가 발생함에도 불구하고 프로그램이 정상적으로 종료될 것이다. 에러를 발생시킬 것이라는 예상이 맞았기 때문이다. 여기서는 오히려 에러를 발생시키지 않으면 <code>AssertionError</code>가 발생한다.</p>
<p><code>throws()</code> 메소드에는 함수 블럭말고도 발생하는 에러의 조건이 될 수 있는 추가적인 인자를 넘길 수 있다. <code>throw()</code> 호출 코드를 다음과 같이 수정한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.throws(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  justModule.throwError(); <span class="comment">// throw ReferenceError</span></div><div class="line">&#125;, <span class="built_in">TypeError</span>); <span class="comment">// can't pass at this time.</span></div></pre></td></tr></table></figure>
<p><code>throwError()</code>라는 메소드는 <code>ReferenceError</code>를 발생시키는데, 인자로 <code>TypeError</code>의 생성자를 전달하였으므로, 예상이 틀리게 되고, 결국 예정된 <code>ReferenceError</code>를 발생시키므로 테스트는 실패한다.</p>
<p>인자로는 생성자말고도, 조건이 되는 함수 블럭, 정규식 등을 넘길 수 있다.</p>
<p><code>doesNotThrow()</code>는 조금 이상한 녀석이다. <code>throws()</code>와 반대성격의 메소드이므로 에러가 발생하지 않을 것임을 예상한다고 볼 수 있는데, 인자로 넘긴 타입과 같은 타입의 에러가 발생하면 <code>AssertionError</code>가 발생하지만, 다른 에러가 발생하면 그냥 그 에러가 발생해서 테스트가 멈춘다. 다음 예제를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.doesNotThrow(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  justModule.throwError(); <span class="comment">// throw ReferenceError</span></div><div class="line">&#125;, <span class="built_in">ReferenceError</span>); <span class="comment">// throw AssertionError</span></div></pre></td></tr></table></figure>
<p>여기서는 발생하지 말아야할 에러가 발생했으므로 <code>AssertionError</code>가 발생한다. 여기서 <code>ReferenceError</code>가 아니라 <code>TypeError</code>를 인자로 넘기면 어떻게 될까? 마치 테스트가 통과될 것 같지 않은가?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">assert.doesNotThrow(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  justModule.throwError(); <span class="comment">// throw ReferenceError</span></div><div class="line">&#125;, <span class="built_in">TypeError</span>); <span class="comment">// can't pass..</span></div></pre></td></tr></table></figure>
<p>하지만 내 예상과는 달리 원래 발생하는 <code>ReferenceError</code>가 그대로 발생한다. 따라서 테스트는 멈추게 된다. 이 쯤에서 이 메소드의 존재의의가 궁금해진다(…) 어차피 에러를 발생시키는 구문이라면 <code>doesNotThrow()</code> 안에서 실행시키지 않아도 테스트를 멈추게 할테니 말이다. 이 부분은 그럴듯한 사례나 이유를 찾지 못했다. 혹시 알고 계신 분은 댓글을 남겨주시기 바란다.</p>
<h3 id="fail"><a href="#fail" class="headerlink" title="fail()"></a>fail()</h3><p><code>fail()</code>은 <del>모 보험처럼 묻지도 따지지도 않고</del> 무조건 <code>AssertionError</code> 에러를 발생시키는 메소드다. <code>doesNotThrow()</code>와 마찬가지로, 굳이 이런 메소드가 필요한지에 대해 의문이 들었는데 실제로도 거의 사용되지 않는 메소드라고 한다. 사용법은 매우 간단하고, 중요하지 않은 메소드이므로 넘어가도록 하겠다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 끝에 와서 맥 빠지는 말이지만, Assert는 실제로는 그렇게 자주 사용되지는 않는 것 같다. 머리말에 밝혔듯이 검증된데다가 가독성도 뛰어난 테스트용 프레임워크/라이브러리가 많기 때문이다. <a href="http://shouldjs.github.io/" target="_blank" rel="external">should.js</a>나 <a href="https://github.com/Automattic/expect.js" target="_blank" rel="external">expect.js</a>는 당장 Assert를 대체할 수 있는데다가 브라우저에서도 사용가능하고 이미 검증되어있는 좋은 테스트 프레임워크다.</p>
<p>하지만 그렇다고 해서 Assert를 공부하는 것 자체가 의미없는 행위는 아니다. 일단 Assert는 서드파티 라이브러리가 아니고 안정적이며, 별도의 설치가 필요 없으므로 작은 프로젝트에도 가볍게 사용할 수 있다. 게다가 should.js의 <code>should</code> 객체는 Assert 모듈을 확장한 것이기 때문에 should.js를 사용할 때도 적용할 수 있다.</p>
<h2 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h2><ul>
<li><a href="https://nelsonic.gitbooks.io/node-js-by-example/content/core/assert/README.html" target="_blank" rel="external">Node.js by Example - Assert</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/assert-nodejs-test-module.jpg&quot;/&gt;&lt;p&gt;요즘은 TDD니, BDD니 해서 테스트의 중요성이 더 없이 강조되고 있다. 워낙 많이 언급되다 보니 여지껏 테스트 코드를 작성할 일이 없었던 나도 조금은 공
    
    </summary>
    
      <category term="Node.js" scheme="https://hyunseob.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://hyunseob.github.io/tags/Node-js/"/>
    
      <category term="Testing" scheme="https://hyunseob.github.io/tags/Testing/"/>
    
  </entry>
  
  <entry>
    <title>CoffeeScript와 ES2015에 대한 생각</title>
    <link href="https://hyunseob.github.io/2016/05/01/thoughts-about-coffeescript-and-es2015/"/>
    <id>https://hyunseob.github.io/2016/05/01/thoughts-about-coffeescript-and-es2015/</id>
    <published>2016-05-01T11:32:07.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/thoughts-about-coffeescript-and-es2015.jpg"/><h2 id="CoffeeScript의-추억"><a href="#CoffeeScript의-추억" class="headerlink" title="CoffeeScript의 추억"></a>CoffeeScript의 추억</h2><blockquote>
<p>명시적인게 묵시적인 것보다 낫다.</p>
<p>- <em><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">The Zen of Python</a></em></p>
</blockquote>
<p><a href="http://coffeescript.org/" target="_blank" rel="external">CoffeeScript</a>는 회사 프로덕트에서 메인으로 쓰고 있는 언어다. 내가 입사한지가 약 10개월 좀 넘었고, 그동안 내내 CoffeeScript를 사용해왔으니 이젠 좀 깔 만한 자격도 생긴 것 같다. 처음 접했을 때는 Python 같다는 생각을 했다. 괄호가 거의 사용되지 않고 indent로 블록을 구분하는 점에서 좀 그렇게 느꼈던 것 같다.(지금 돌아보면 약간 미친 생각같다) 다행히도 Python을 이미 접해본 적이 있었고, 그다지 무리 없이 CoffeeScript에 적응했던 것 같다. 물론 사용하다보니 편한 점도 많았지만 솔직히 나는 이 언어가 마음에 들지 않는다.</p>
<p>난 ‘말 안하면 모르는’ 전형적인 공대 남자다. 말 안해도 내 맘 좀 알아달라는 요구, 그런 거 잘 못 들어준다.(물론 여자친구가 없기 때문에 그런 요구 당할 일이 없어서 좀 편하다) 그런데 CoffeeScript는 뭐랄까.. “하.. 오빤 내가 말 안해도 내가 여기서 리턴하는 거 알아주면 안돼?” 라고 말하는 여자친구 같다. 매우 짜증나고 무섭다. 생략하는 게 몹시 많다. <code>return</code>, 각종 괄호, 세미콜론, 쉼표 등등.. 그 중 AngularJS를 쓸 때 묵시적인 리턴으로 에러가 종종 발생한다. 이게 얼마나 많이 일어나는 일이면 <a href="https://docs.angularjs.org/error/$parse/isecdom" target="_blank" rel="external">AngularJS Docs</a>에 관련 내용이 언급되어 있을까? 이제는 너무 자주 겪어서 에러나면 기계적으로 <code>return</code> 써준다. 결국 묵시적인 리턴이 명시적인 리턴을 하게 만들고 있다. 아놔..</p>
<p>이제 왜 초입에 The Zen of Python의 구절을 인용했는지 아실 것이다. 이 Python의 철학을 Python 쓰다가 느끼지 않고, CoffeeScript를 쓰면서 절절히 체감했다. 역시 뭐 공부하는데는 안티 패턴이 짱이다.</p>
<h2 id="ES2015를-접하다"><a href="#ES2015를-접하다" class="headerlink" title="ES2015를 접하다"></a>ES2015를 접하다</h2><p><a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="external">ES2015</a>(ES6)라는 걸 처음 들은 것은 아마 작년에 React 스터디를 나갔을 때 였던 것 같다. 지금도 쪼렙이지만 그 땐 더더욱 허접했다. 그냥 JavaScript, 그리고 회사에서 주력으로 사용하고 있는 프레임워크 AngularJS조차 제대로 사용하지도 못하면서 그냥 요즘 핫하다고 하니까 한 번 공부해볼까 하는 요량으로 갔던 것 같다. 지금 생각해보면 정말 오만방자한 판단이다. 그러니 스터디에 나가서도 무슨 소리를 하는 건지 하나도 모르겠어서 쩔쩔매고 자괴감에 빠져가지고는 공부도 열심히 안했다. 그런데 스터디가 제대로 될 턱이 있나.</p>
<p>그래도 아예 얻은 게 하나도 없지는 않았다. 같은 개발자를 만나면 으레 그렇듯, 몇 가지의 키워드는 얻을 수 있었다. React는 jsx를 사용하기 때문에 <a href="https://babeljs.io/" target="_blank" rel="external">Babel</a> 같은 transpiler를 사용하게 되는데, Babel에 대해서 얘기하는 걸 듣고는 Babel이 뭐지? 하고 찾아보다가 ES2015라는, JavaScript의 새로운 표준이 나와있구나. 그리고 Babel로 이걸 좀 옛날 JavaScript로도 바꿀 수 있구나. 이런 걸 좀 알게 되었던 것 같다. 그러고 보면 스터디에서 얻은 게 별로 없다기보단 좋은 경험을 얻었다는 생각이 든다. (근데 React는 여전히 하나도 모름)</p>
<h2 id="그래도-계속"><a href="#그래도-계속" class="headerlink" title="그래도 계속.."></a>그래도 계속..</h2><p>하지만 회사에서는 여전히 CoffeeScript를 사용하고 있었다. (물론 이건 지금도 마찬가지. 코드베이스를 갈아 엎으려면 비용이..) ES2015를 알게 된 이후에도 어떤 문법적 기능이 지원되는지 잘 몰랐기 때문에 딱히 도입의 필요성을 느끼지도 못했고, CoffeeScript의 Syntactic sugar도 잘 쓰고 있었기 때문에 특별히 ES2015에 더 관심도 없었다.</p>
<p>난 JavaScript를 제대로 접한지 얼마되지 않았기 때문에 당연히 JavaScript 기본기가 부족했는데, CoffeeScript를 계속 사용하면 점점 JavaScript 기본 문법을 잘 모르게 될 뿐만 아니라, 내가 사용하는 문법들이 JavaScript에서도 원래 그런 건지, CoffeeScript에서 어떤 특별한 이유가 있어서 그런 문법을 사용하는 건지도 모호하게 느꼈다. 결국 JavaScript 기본기는 많이 늘지 않았던 것이다.(내가 공부 안 한 것도 있고..) 그렇게 시간이 점차 지나면서 점점 JavaScript 기본기에 대한 열망만 커졌었던 것 같다. 솔직히 지금은 CoffeeScript는 충분히 JavaScript 기본기가 다져져 있는 사람만 사용해야 하는 언어라고 생각한다. 나같은 허접에게는 적절하지 않다.</p>
<p>뭐 어쨌든 그렇게 CoffeeScript를 쓰다가 몇 달 전에 Kevin TV에서 <a href="https://www.youtube.com/watch?v=BtKzJdoelso" target="_blank" rel="external">ES2015 특집</a>을 보게되었고 거기에서 <a href="https://github.com/DrkSephy/es6-cheatsheet" target="_blank" rel="external">ES6 Cheatsheet</a>라는 프로젝트를 발견하고 그 글을 번역하면서 ES2015의 새로운 문법과 기능들을 약간이나마 이해하게 되었다. 회사 프로젝트에 도입하지는 못했지만, 요즘은 개인 프로젝트로 코딩할 때 가급적이면 ES2015 문법들을 사용하려고 노력하고 있다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>Babel 같은 도구도 있고, 모던 브라우저들, Node.js까지 최근에 6버전을 내면서 ES2015의 지원률을 90% 이상으로 끌어올린 마당에 더 이상 새로운 프로젝트에 CoffeeScript를 도입할 이유가 없다. CoffeeScript에 있는 편리한 문법(e.g. Arrow functions, Classes)들이 ES2015에도 포함되어있고, destructuring 같은 것은 ES2015에서 먼저 도입했다가 나중에 CoffeeScript에도 도입이 된 녀석이다. CoffeeScript는 <code>[0..n]</code> 같이 일부 편리한 문법을 제공하지만 이런 건 그냥 코드 몇 줄 더 적어도 상관없고, 뭣하면 함수로 구현해두면 된다.</p>
<p>게다가, 위의 사례에서 볼 때 코드량이 줄어드는 게 무조건 좋은 일인가? 더 적은 타이핑이 더 높은 생산성을 가져다 주진 않는다. 우리가 제프 딘도 아닌데 어떻게 쉬지 않고 타이핑을 한단 말인가? 어차피 개발하는 시간의 대부분은 그냥 생각하는 시간이다.</p>
<p>그리고 CoffeeScript는 표준이 아니다. 뭐 언젠가 ES2015로 컴파일되는 날이 올 수도 있긴 하겠다. 다만 그 때는 이미 대부분의 브라우저가 ES2015를 100%에 가깝게 구현하고 있을 텐데, 그 쯤 되면 이미 개발자들은 ES2016으로 넘어가고 있을 것이다. 그러니까 지금은 앞으로도 쭉 표준 스펙일, 내 JavaScript 기본기에 도움이 될 ES2015를 공부하는 게 맞다고 생각한다.</p>
<h2 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h2><ul>
<li><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES6 compatibility table</a></li>
<li><a href="http://programmaticallyspeaking.com/why-i-hate-implicit-return-in-coffeescript.html" target="_blank" rel="external">Why I hate implicit return in CoffeeScript</a></li>
<li><a href="http://readme.skplanet.com/?p=12183" target="_blank" rel="external">Front-end 개발의 괜찮은 선택 ES6 &amp; ReactJS</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/thoughts-about-coffeescript-and-es2015.jpg&quot;/&gt;&lt;h2 id=&quot;CoffeeScript의-추억&quot;&gt;&lt;a href=&quot;#CoffeeScript의-추억&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/categories/Opinion/"/>
    
    
      <category term="ES2015" scheme="https://hyunseob.github.io/tags/ES2015/"/>
    
      <category term="CoffeeScript" scheme="https://hyunseob.github.io/tags/CoffeeScript/"/>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/tags/Opinion/"/>
    
  </entry>
  
  <entry>
    <title>[lodash/underscore] throttle과 debounce</title>
    <link href="https://hyunseob.github.io/2016/04/24/throttle-and-debounce/"/>
    <id>https://hyunseob.github.io/2016/04/24/throttle-and-debounce/</id>
    <published>2016-04-23T15:47:05.000Z</published>
    <updated>2017-01-17T15:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/throttle-and-debounce.jpg"/><h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><blockquote>
<p>매 밀리세컨드마다 최대 한 번만 호출될 수 있도록 Throttle된 함수를 만듭니다.</p>
<p>– <em>throttle by lodash</em></p>
</blockquote>
<p><a href="https://lodash.com/docs#throttle" target="_blank" rel="external">throttle - lodash</a><br><a href="http://underscorejs.org/#throttle" target="_blank" rel="external">throttle - underscore</a></p>
<p>DOM API 중 <code>onmousemove</code>, <code>onmouseover</code>, <code>onscroll</code> 같은 이벤트는 1초 안에도 수 십 번씩 과다하게 호출될 수 있다. 이런 이벤트에 무거운 로직을 끼워두면 당연히 웹페이지의 성능이 떨어질 수 밖에 없다. 따라서 로직이 적당히 호출될 수 있도록 조절하는 작업이 필요한데, 이 때 간편하게 사용할 수 있는 것이 <code>_.throttle</code>이다.</p>
<p><code>_.throttle</code>은 로직 실행 주기를 만드는 함수라고 이해하면 된다. 밀리세컨드 단위로 시간을 설정하면 <code>_.throttle</code>에 넘긴 콜백함수는 설정한 시간 동안 최대 한 번만 호출된다.</p>
<p>다음 예제를 보면 이해가 빠를 것이다.</p>
<script async src="https://jsfiddle.net/HyunSeob/xLt1a75f/2/embed/js,result/dark/"></script>

<p>위에서는 <code>_.throttle</code> 함수를 100 밀리세컨드 단위로 설정했다. 마우스를 올려놓고 움직여보면 throttle된 함수와 안된 함수의 차이가 드러나는 것을 볼 수 있다. 실제로 100~200 밀리세컨드 정도의 throttle은 throttle을 적용하지 않았을 때에 비해서 UX적인 차이가 크게 드러나지 않아 부담없이 적용할 수 있는 편이다.</p>
<p><code>_.throttle</code>을 사용할 만한 실제 사례는 Infinite scroll을 생각해 볼 수 있겠다. Infinite scroll에서는 대개 AJAX 요청을 보내게 될 텐데, <code>onscroll</code>에 AJAX 요청을 바인딩해놓으면 스크롤 이벤트가 많이 일어나므로 과다한 요청을 보내게 된다. 당연하지만 이런 요청은 클라이언트와 서버, 모두 부담되기 때문에 적당한 양의 요청을 보내도록 조절해야 한다. 딱 <code>_.throttle</code>을 사용하기에 적당한 상황이다. 다음은 실제로 AJAX 요청을 보내지는 않지만 Infinite scroll을 구현한 예제이다.</p>
<script async src="https://jsfiddle.net/HyunSeob/xLt1a75f/5/embed/js,result/dark/"></script>

<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><blockquote>
<p>마지막 호출 이후 일정 밀리세컨드 이후로 지연된 호출을 하도록 debounce된 함수를 만듭니다.</p>
<p>– <em>debounce by lodash</em></p>
</blockquote>
<p><a href="https://lodash.com/docs#debounce" target="_blank" rel="external">debounce - lodash</a><br><a href="http://underscorejs.org/#debounce" target="_blank" rel="external">debounce - underscore</a></p>
<p><code>_.debounce</code>는 <code>_.throttle</code>과 마찬가지로 과다한 이벤트 로직 실행을 방지하기 위해 사용되는 함수이다. 바로 실행되는 <code>_.throttle</code>과는 달리 호출이 반복되는 동안에는 로직 실행을 방지하며, 호출이 멈춘 뒤, 설정한 시간이 지나고 나서야 로직을 실행하게 된다.</p>
<script async src="https://jsfiddle.net/HyunSeob/xLt1a75f/7/embed/js,result/dark/"></script>

<p>이번에도 마우스를 올려놓고 움직여보면 어떤 식인지 쉽게 감이 올 것이다. <code>_.debounce</code>는 100 밀리세컨드로 설정되었다. 즉, 마우스를 멈춘 뒤 100 밀리세컨드가 지나면 카운트가 오른다.</p>
<p><code>_.debounce</code> 역시 실제로 자주 활용되는데, 가장 자주 활용되는 사례로는 AJAX 요청을 이용하는 검색 인터페이스(Autocomplete)가 있겠다. 검색을 담당하는 input 요소에 무언가를 타이핑 할 때마다 AJAX 요청을 보내는 것은 마찬가지로 과도한 부담이다. 따라서 유저가 타이핑을 마쳤다고 예상되는 지점에서 요청을 보내는 것이 적당하다. 그럴 때 <code>_.debounce</code>를 사용해서 유저가 타이핑을 멈춘 뒤, 몇 밀리세컨드 이후에 요청을 보내면 되는 것이다.</p>
<script async src="https://jsfiddle.net/HyunSeob/xLt1a75f/embed/js,result/dark/"></script>

<p>마찬가지로 진짜 AJAX 요청을 보내고 있지는 않지만 debounce된 함수를 사용하는 예제이다. 이런 식의 검색 인터페이스는 이미 많은 곳에서 채택되었다. 대표적으로 페이스북. 실제로 검색해보면 타이핑하는 동안에는 검색결과가 노출되지 않는데 타이핑을 멈춘 뒤 약간 시간이 지나야 검색이 실행되는 모습을 볼 수 있다. 물론 클라이언트에 저장된 정보는 바로 검색된다. 이 경우에는 AJAX 요청만 debounce된 것이라고 볼 수 있겠다. (물론 페이스북이 lodash나 underscore를 쓰는지는 모르겠지만..)</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>얼마 전에 debounce된 AJAX 요청을 구현해야 할 일이 있었는데, 그 땐 이런 함수가 있다는 것 조차 몰랐기 때문에, 한참 헤메다가 <code>setTimeout</code>과 Promise를 이용해서 얼기설기 구현했던 기억이 난다. 이 포스트가 그렇게 헤메고 있는 사람들에게 도움이 되었으면 한다.</p>
<h2 id="참고링크"><a href="#참고링크" class="headerlink" title="참고링크"></a>참고링크</h2><ul>
<li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="external">Debounce and Throttle: a visual explanation - Drupal motion</a></li>
<li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="external">Debouncing and Throttling Explained Through Examples - CSS-Tricks</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/throttle-and-debounce.jpg&quot;/&gt;&lt;h2 id=&quot;throttle&quot;&gt;&lt;a href=&quot;#throttle&quot; class=&quot;headerlink&quot; title=&quot;throttle&quot;&gt;&lt;/a&gt;throttle&lt;/h2&gt;&lt;bl
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="lodash/underscore" scheme="https://hyunseob.github.io/categories/JavaScript/lodash-underscore/"/>
    
    
      <category term="DOM" scheme="https://hyunseob.github.io/tags/DOM/"/>
    
      <category term="underscore.js" scheme="https://hyunseob.github.io/tags/underscore-js/"/>
    
      <category term="lodash" scheme="https://hyunseob.github.io/tags/lodash/"/>
    
  </entry>
  
</feed>
